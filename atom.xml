<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alan_</title>
  
  <subtitle>Code Change The Word</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-31T10:26:54.545Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Alan_</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试</title>
    <link href="http://example.com/2021/10/31/%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2021/10/31/%E6%B5%8B%E8%AF%95/</id>
    <published>2021-10-31T10:21:17.000Z</published>
    <updated>2021-10-31T10:26:54.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sadasd"><a href="#sadasd" class="headerlink" title="sadasd"></a>sadasd</h1><p>Dasd</p><p>salads</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sadasd&quot;&gt;&lt;a href=&quot;#sadasd&quot; class=&quot;headerlink&quot; title=&quot;sadasd&quot;&gt;&lt;/a&gt;sadasd&lt;/h1&gt;&lt;p&gt;Dasd&lt;/p&gt;
&lt;p&gt;salads&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="sdaa" scheme="http://example.com/tags/sdaa/"/>
    
  </entry>
  
  <entry>
    <title>Lc743-网络延迟时间</title>
    <link href="http://example.com/2021/10/22/Lc743-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/"/>
    <id>http://example.com/2021/10/22/Lc743-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</id>
    <published>2021-10-22T01:44:21.000Z</published>
    <updated>2021-10-23T14:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有 n 个网络节点，标记为 1 到 n。</p><p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/pic/lc743" alt="image-20211022095441991"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：times = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]], n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><ul><li>1 &lt;= k &lt;= n &lt;= 100</li><li>1 &lt;= times.length &lt;= 6000</li><li>times[i].length == 3</li><li>1 &lt;= ui, vi &lt;= n</li><li>ui != vi</li><li>0 &lt;= wi &lt;= 100</li><li>所有 (ui, vi) 对都 互不相同（即，不含重复边）</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>通过邻接矩阵的方式建图,矩阵初始化为INF</li><li>定义一个数组保存某点到源点的距离</li><li>利用迪杰斯特拉算法求源点到所有点的最短路<ol><li>初始化一个visted数组,初始时所有点为false代表该点未确定最短距离</li><li>初始化一个dist数组为INF代表该点到原点的最短距离</li><li>dist[k] = 0 源点到源点的距离为0</li><li>循环遍历所有点，先找到未缺定点中距离最小的点记为t</li><li>标记t已确认</li><li>用t更新图中其它点的最短路</li></ol></li><li>找到最短路距离中最大的即为答案</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><h2 id="Dijkstra-amp-Floyd"><a href="#Dijkstra-amp-Floyd" class="headerlink" title="Dijkstra&amp;Floyd"></a>Dijkstra&amp;Floyd</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">6010</span>;</span><br><span class="line">    <span class="comment">//邻接矩阵存图</span></span><br><span class="line">    <span class="keyword">int</span>[][] w = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="comment">//记录点到原点的最近距离</span></span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="comment">//记录哪些点被更新</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visted = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> _n, <span class="keyword">int</span> _k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = _n;</span><br><span class="line">        <span class="keyword">this</span>.k = _k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    w[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    w[i][j] = INF;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time:times)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = time[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = time[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> c = time[<span class="number">2</span>];</span><br><span class="line">            w[u][v] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// //最短路</span></span><br><span class="line">        <span class="comment">// dijkstra();</span></span><br><span class="line">        <span class="comment">// //遍历答案</span></span><br><span class="line">        <span class="comment">// int ans = 0;</span></span><br><span class="line">        <span class="comment">// for(int i = 1;i &lt;= n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     ans = Math.max(ans,dist[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        floyd();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            ans = Math.max(ans,w[k][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; INF / <span class="number">2</span> ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化visted和dist</span></span><br><span class="line">        Arrays.fill(visted,<span class="keyword">false</span>);</span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        <span class="comment">//起点的最短距离为0</span></span><br><span class="line">        dist[k] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>;p &lt;= n;p++)&#123;</span><br><span class="line">            <span class="comment">//从未确定的点中找到距离最近的点</span></span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visted[i] &amp;&amp; (t == -<span class="number">1</span> || dist[i] &lt; dist[t]))&#123;</span><br><span class="line">                    t = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//标记t已确认</span></span><br><span class="line">            visted[t] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//用t更新其它点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">                dist[i] = Math.min(dist[i],dist[t] + w[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                    w[i][j] = Math.min(w[i][j],w[i][k] + w[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">110</span>;<span class="comment">// 点数</span></span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">6010</span>; <span class="comment">// 边数</span></span><br><span class="line">    <span class="comment">//定义邻接表</span></span><br><span class="line">    <span class="keyword">int</span>[] he = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="comment">//记录从i点到源点的最短距离为dist[i]</span></span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="comment">//记录哪个点已在队列中</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visted = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="comment">//添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = he[a];</span><br><span class="line">        he[a] = idx;</span><br><span class="line">        w[idx] = c;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] ts, <span class="keyword">int</span> _n, <span class="keyword">int</span> _k)</span> </span>&#123;</span><br><span class="line">         n = _n; k = _k;</span><br><span class="line">        <span class="comment">// 初始化链表头</span></span><br><span class="line">        Arrays.fill(he, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 存图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] t : ts) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = t[<span class="number">0</span>], v = t[<span class="number">1</span>], c = t[<span class="number">2</span>];</span><br><span class="line">            add(u, v, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最短路</span></span><br><span class="line">        spfa();</span><br><span class="line">        <span class="comment">// 遍历答案</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; INF / <span class="number">2</span> ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(visted,<span class="keyword">false</span>);</span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记k已经已入队</span></span><br><span class="line">        <span class="comment">//使用队列存储编号</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(k);</span><br><span class="line">        visted[k] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//每次从队列取出一个节点，并标为未入队</span></span><br><span class="line">            <span class="keyword">int</span> t = queue.poll();</span><br><span class="line">            visted[t] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//用该点更新其它点的最短距离</span></span><br><span class="line">            <span class="comment">//如果更新的点，本身未入队，则加入队列中，并标记已入队</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = he[t];i != -<span class="number">1</span>;i = ne[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                    dist[j] = dist[t] + w[i];</span><br><span class="line">                    <span class="keyword">if</span>(!visted[j])&#123;</span><br><span class="line">                        queue.offer(j);</span><br><span class="line">                        visted[j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>朴素迪杰斯特拉算法和spfa算法用于单源汇求最短路场景，区别在于迪杰斯特拉只能在无负权边的场景下使用。</p><p>Floyd适用于在多源汇场景下求最短路</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;有 n 个网络节点，标记为 1 到 n。&lt;/p&gt;
&lt;p&gt;给你一个列表 times，表示信号经过 有向 边的传递时间。 tim</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc139-单词拆分</title>
    <link href="http://example.com/2021/10/19/Lc139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://example.com/2021/10/19/Lc139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2021-10-19T02:54:37.000Z</published>
    <updated>2021-10-19T03:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;leetcode&quot;</span>, wordDict = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="string">&quot;leet code&quot;</span>。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;applepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="string">&quot;apple pen apple&quot;</span>。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;catsandog&quot;</span>, wordDict = [<span class="string">&quot;cats&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;sand&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;cat&quot;</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li><p>完全背包问题，定义dp数组：dp[i]表示字符串长度为i时,若dp[i] = true可以拆成一个或多个在字典中的单词</p></li><li><p>状态转移方程</p><blockquote><p>if(dp[j] &amp;&amp; wordDict.contains(s.substring(j,i)))</p><p>​    dp[i] = true;</p></blockquote><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。</p></li><li><p>初始化:初始时dp[0] = true,其它初始化为false</p></li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j,i)))&#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc48-旋转图像</title>
    <link href="http://example.com/2021/10/18/Lc48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>http://example.com/2021/10/18/Lc48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2021-10-18T13:12:26.000Z</published>
    <updated>2021-10-18T13:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/pic/lc48.png" alt="image-20211018090006186"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[[<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>先按对角线交换</li><li>在按中线交换</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tem = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tem = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][n - j - <span class="number">1</span>] = tem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;你必须在 原地</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://example.com/2021/10/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/10/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-10-17T13:19:19.000Z</published>
    <updated>2021-10-18T13:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP 是 Consistency、Availability、Partition tolerance 三个单词的缩写，分别表示一致性、可用性、分区容忍性。已商品服务为例：</p><p><img src="/pic/capeg.png" alt="image-20211017212257228"></p><p>整体执行流程如下</p><ol><li>商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）</li><li>主数据库向商品服务响应写入成功</li><li>商品服务请求从数据库读取商品信息</li></ol><h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h2><p> 一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态。</p><p>上图中，商品信息的读写要满足一致性就是要实现如下目标：</p><ol><li>商品服务写入主数据库成功，则向从数据库查询新数据也成功。</li><li>商品服务写入主数据库失败，则向从数据库查询新数据也失败。</li></ol><p>如何实现一致性？</p><ol><li>写入主数据库后要将数据同步到从数据库。</li><li>写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功后，向从数据库查询到旧的数据。</li></ol><p>分布式系统一致性的特点：</p><ol><li><strong>由于存在数据同步的过程，写操作的响应会有一定的延迟。</strong></li><li><strong>为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。</strong></li><li><strong>如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。</strong></li></ol><h2 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性(Availability)"></a>可用性(Availability)</h2><p>可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。</p><p>上图中，商品信息读取满足可用性就是要实现如下目标：</p><ol><li>从数据库接收到数据查询的请求则立即能够响应数据查询结果。</li><li>从数据库不允许出现响应超时或响应错误。</li></ol><p>如何实现可用性</p><ol><li><p>写入主数据库后要将数据同步到从数据库。</p></li><li><p>由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。</p></li><li><p>即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照约定返回一个默认信息，但不能返回错误或响应超时。</p></li></ol><p>分布式系统可用性的特点：<strong>所有请求都有响应，且不会出现响应超时或响应错误</strong></p><h2 id="分区容错性-Partition-tolerance"><a href="#分区容错性-Partition-tolerance" class="headerlink" title="分区容错性(Partition tolerance)"></a>分区容错性(Partition tolerance)</h2><p>通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务，这叫分区容忍性。</p><p>上图中，商品信息读写满足分区容忍性就是要实现如下目标：</p><ol><li><p>主数据库向从数据库同步数据失败不影响读写操作。</p></li><li><p>其一个结点挂掉不影响另一个结点对外提供服务。</p></li></ol><p>如何实现分区容忍性？</p><ol><li><p>尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现松耦合。</p></li><li><p>添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。</p></li></ol><p>分布式分区容忍性的特点：<strong>分区容忍性分是布式系统具备的基本能力</strong></p><h2 id="CAP组合方式"><a href="#CAP组合方式" class="headerlink" title="CAP组合方式"></a>CAP组合方式</h2><p><strong>在所有分布式事务场景中不会同时具备 CAP 三个特性，因为在具备了P的前提下C和A是不能共存的</strong></p><p><img src="/pic/capeg.png" alt="image-20211017212257228"></p><p>本图分区容忍的含义是：</p><ol><li>主数据库通过网络向从数据库同步数据，可以认为主从数据库部署在不同的分区，通过网络进行交互。</li><li>当主数据库和从数据库之间的网络出现问题不影响主数据库和从数据库对外提供服务。</li><li>其中一个节点挂掉不影响另一个节点对外提供服务。</li></ol><p>如果要实现 C 则必须保证数据一致性，在数据同步的时候为防止向从数据库查询不一致的数据则需要将从数据库数据锁定，待同步完成后解锁，如果同步失败从数据库要返回错误信息或超时信息。</p><p>如果要实现 A 则必须保证数据可用性，不管任何时候都可以向从数据查询数据，则不会响应超时或返回错误信息。通过分析发现在满足P的前提下 C 和 A 存在矛盾性。</p><ol><li><strong>AP</strong><br>放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。<br>例如：上边的商品管理，完全可以实现 AP，前提是只要用户可以接受所查询到的数据在一定时间内不是最新的即可。<br>通常实现 AP 都会保证最终一致性，后面将的 <strong>BASE</strong> 理论就是根据 AP 来扩展的，一些业务场景比如：订单退款，今日退款成功，明日账户到账，只要用户可以接受在一定的时间内到账即可。</li><li><strong>CP</strong><br>放弃可用性，追求一致性和分区容错性，zookeeper 其实就是追求的强一致，又比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。</li><li><strong>CA</strong><br>放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统，最常用的关系型数据就满足了 CA。</li></ol><h1 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h1><ol><li>强一致性和最终一致性<br>CAP 理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP 即舍弃一致性，保证可用性和分区容忍性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和 CAP 中的一致性不同，CAP 中的一致性要求 在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。</li><li>Base 理论介绍<br>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写。BASE 理论是对 CAP 中 AP 的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“<strong>柔性事务</strong>”。</li><li><strong>基本可用</strong>：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。</li><li><strong>软状态</strong>：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫<strong>软状态</strong>），这个状态不影响系统可用性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。</li><li><strong>最终一致</strong>：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变 为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ol><h1 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h1><p>2PC 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2 是指两个阶段，P 是指准备阶段，C 是指提交阶段。</p><p>整个事务过程由事务管理器和参与者组成，事务参与者负责自己本地事务的提交和回滚</p><p>在计算机中部分关系数据库如 Oracle、MySQL 支持两阶段提交协议，如下图</p><ol><li>准备阶段（Prepare phase）：事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务，并写本地的 Undo/Redo 日志，此时事务没有提交。（Undo 日志是记录修改前的数据，用于数据库回滚，Redo 日志是记录修改后的数据，用于提交事务后写入数据文件）</li><li>提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：<strong>必须在最后阶段释放锁资源</strong>。</li></ol><h2 id="XA事务"><a href="#XA事务" class="headerlink" title="XA事务"></a>XA事务</h2><ol><li><p>整个 2PC 的事务流程涉及到三个角色 AP、RM、TM。AP 指的是使用 2PC 分布式事务的应用程序；RM 指的是资源管理器，它控制着分支事务；TM 指的是事务管理器，它控制着整个全局事务。</p><p>（1）在<strong>准备阶段</strong> RM 执行实际的业务操作，但不提交事务，资源锁定</p><p>（2）在<strong>提交阶段</strong> TM 会接受 RM 在准备阶段的执行回复，只要有任一个RM执行失败，TM 会通知所有 RM 执行回滚操作，否则，TM 将会通知所有 RM 提交该事务。提交阶段结束资源锁释放。</p></li></ol><h2 id="XA事务带来的问题"><a href="#XA事务带来的问题" class="headerlink" title="XA事务带来的问题"></a>XA事务带来的问题</h2><ol><li>需要本地数据库支持XA协议。</li><li>资源锁需要等到两个阶段结束才释放，性能较差。</li></ol><h1 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h1><p>传统 2PC 的问题在 Seata 中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务 0 侵入的方式解决微服务场景下面临的分布式事务问题，它目前提供 AT 模式（即 2PC）及 TCC 模式的分布式事务解决方案。</p><p>Seata 把一个分布式事务理解成一个包含了若干<strong>分支事务</strong>的<strong>全局事务</strong>。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务，下图是全局事务与分支事务的关系图：</p><p><img src="/pic/seata.png" alt="image-20211017214243352"></p><p>与传统 2PC 的模型类似，Seata 定义了 3 个组件来协议分布式事务的处理过程</p><ul><li>Transaction Coordinator（TC）：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收 TM 指令发起全局事务的提交与回滚，负责与 RM 通信协调各各分支事务的提交或回滚。</li><li>Transaction Manager（TM）： 事务管理器，TM 需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向 TC 发起全局提交或全局回滚的指令。</li><li>Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚。</li></ul><p>新用户注册送积分举例Seata的分布式事务过程：</p><ol><li>用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。</li><li>用户服务的 RM 向 TC 注册分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局事务的管辖。</li><li>用户服务执行分支事务，向用户表插入一条记录。</li><li>逻辑执行到远程调用积分服务时（XID 在微服务调用链路的上下文中传播）。积分服务的 RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖。</li><li>积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。</li><li>用户服务分支事务执行完毕。</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li></ol><p>架构层次方面：传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而 Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用程序这一侧的。</p><h2 id="Seata实现2PC与传统2PC的差别"><a href="#Seata实现2PC与传统2PC的差别" class="headerlink" title="Seata实现2PC与传统2PC的差别"></a><strong>Seata实现2PC与传统2PC的差别</strong></h2><p>两阶段提交方面：传统 2PC无论第二阶段的决议是 commit 还是 rollback ，事务性资源的锁都要保持到 Phase2 完成才释放。而 Seata 的做法是在 Phase1 就将本地事务提交，这样就可以省去 Phase2 持锁的时间，整体提高效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h1&gt;&lt;p&gt;CAP 是 Consistency、Availability、Partition tolerance 三个单词的缩写</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Lc61-循环链表</title>
    <link href="http://example.com/2021/10/17/Lc61-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/10/17/Lc61-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</id>
    <published>2021-10-17T01:04:30.000Z</published>
    <updated>2021-10-17T01:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/pic/lc61.png" alt="image-20211017090756152"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>计算出链表长度</li><li>新链表头节点位置就是k =  k mod len</li><li>维护快慢指针，快指针先走k步,随后快慢指针共同向前走，直到到达链表末尾</li><li>让快指针指向链表head节点，使其成环</li><li>从慢节点位置处断开即可称为旋转后的链表</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tem = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tem != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tem = tem.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % len;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast.next = head;</span><br><span class="line">        head = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，旋转链表，将链表每个节点向右移动 &lt;code&gt;k&lt;/code&gt; </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc279-完全平方数</title>
    <link href="http://example.com/2021/10/15/Lc279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>http://example.com/2021/10/15/Lc279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</id>
    <published>2021-10-15T00:47:32.000Z</published>
    <updated>2021-10-15T06:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">13</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>完全背包问题，1~根号n之间的平方数就是物品，完全平方数得和就是背包容量</li><li>定义dp数组:dp[i]代表和为i的完全平方数的最少数量为为dp[i]</li><li>状态转移:dp[i] 可由dp[i - j*j] 转移而来,dp[i - j * j] + 1就是dp[i]</li><li>由于要求数量最少所以dp[i] = Math.min(dp[i],dp[i - j * j] + 1)</li><li>dp数组初始化，由状态转移方程可知:dp[i]需要初始化最大，结果才能不被覆盖，dp[0] = 0</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j * j &lt;= i;j++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc227-基本计算器</title>
    <link href="http://example.com/2021/10/14/Lc227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://example.com/2021/10/14/Lc227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2021-10-14T08:24:50.000Z</published>
    <updated>2021-10-14T13:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h1><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;3+2*2&quot;</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot; 3/2 &quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot; 3+5 / 2 &quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>利用一个map存储运算符的优先级，维护两个栈，一个存数，一个存操作符</li><li>遍历字符数组，遇到<code>(</code>压栈，遇到<code>)</code>将栈内元素进行计算，知道遇到<code>(</code></li><li>如果遇到数字，计算数字大小，进行压栈</li><li>如果遇到的是运算符，在入栈前需要将优先级大于等于该运算符的数进行计算，计算完将数压栈</li><li>数字栈栈顶元素即为结果。</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        map.put(<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;^&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        Stack&lt;Integer&gt; num = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Character&gt; ops = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ops.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!ops.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ops.peek() == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        calc(ops,num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(isNumber(c))&#123;</span><br><span class="line">                    <span class="keyword">int</span> j = i;</span><br><span class="line">                    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; n &amp;&amp; isNumber(arr[j]))&#123;</span><br><span class="line">                        u = u * <span class="number">10</span> + (arr[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num.push(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!ops.isEmpty() &amp;&amp; ops.peek() != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">char</span> pre = ops.peek();</span><br><span class="line">                        <span class="keyword">if</span>(map.get(pre) &gt;= map.get(c))&#123;</span><br><span class="line">                            calc(ops,num);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                        ops.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(!ops.isEmpty())&#123;</span><br><span class="line">            calc(ops,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(Stack&lt;Character&gt; ops,Stack&lt;Integer&gt; num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.isEmpty() || num.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ops.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = num.pop();</span><br><span class="line">        <span class="keyword">int</span> a = num.pop();</span><br><span class="line">        <span class="keyword">char</span> op = ops.pop();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            ans = a + b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            ans = a - b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            ans = a * b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            ans = a / b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) Math.pow(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        num.push(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目表述&quot;&gt;&lt;a href=&quot;#题目表述&quot; class=&quot;headerlink&quot; title=&quot;题目表述&quot;&gt;&lt;/a&gt;题目表述&lt;/h1&gt;&lt;p&gt;给你一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。&lt;/</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc92-翻转[m,n]区间的链表</title>
    <link href="http://example.com/2021/10/10/Lc92-%E7%BF%BB%E8%BD%AC-m-n-%E5%8C%BA%E9%97%B4%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/10/10/Lc92-%E7%BF%BB%E8%BD%AC-m-n-%E5%8C%BA%E9%97%B4%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2021-10-10T09:45:12.000Z</published>
    <updated>2021-10-10T11:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/pic/lc92.png" alt="image-20211010174629093"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], left = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>当left = 1时，就是翻转前n个节点</li><li>因此left = 1就是我们递归终止条件，只需让head节点每次前进。直到left = 1</li><li>翻转前n个节点，其实就是当n  = 1时就是最后一个节点，和翻转所有节点一样，唯一区别就是需要记录一下n后面节点，翻转后需要连接上</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverse(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next,left - <span class="number">1</span>,right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//翻转前n个节点</span></span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverse(head.next,n - <span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = next;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目概述&quot;&gt;&lt;a href=&quot;#题目概述&quot; class=&quot;headerlink&quot; title=&quot;题目概述&quot;&gt;&lt;/a&gt;题目概述&lt;/h1&gt;&lt;p&gt;给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &amp;lt;= right 。请你反转从位</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc718-最长重复子数组</title>
    <link href="http://example.com/2021/10/10/Lc718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2021/10/10/Lc718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2021-10-10T09:30:04.000Z</published>
    <updated>2021-10-10T09:37:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h1><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">A: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">B: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">长度最长的公共子数组是 [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>动态规划求解子数组与子序列问题，区别在于子数组要求连续</li><li>定义dp,dp[i][j]代表以num[i - 1]和nums[j - 1]为结尾的重复子数组长度为dp[i][j]</li><li>状态转移方程:当nums[i - 1] = nums[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + 1,如若不等，将不满足连续定义，没有转移关系</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    len = Math.max(len,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目概述&quot;&gt;&lt;a href=&quot;#题目概述&quot; class=&quot;headerlink&quot; title=&quot;题目概述&quot;&gt;&lt;/a&gt;题目概述&lt;/h1&gt;&lt;p&gt;给两个整数数组 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，返回两个数组中公共的、长度最长的子数组的长</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc25-K个一组翻转链表</title>
    <link href="http://example.com/2021/10/09/Lc25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/10/09/Lc25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2021-10-09T13:40:18.000Z</published>
    <updated>2021-10-09T13:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h1><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/pic/lc25.png" alt="image-20211009214548283"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>循环遍历k遍，找到k个节点，先翻转这一部分</li><li>先翻转区间[m,n]之间的节点</li><li>分组在递归反转后面的节点</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode l2 = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode l1 = reverse(head,l2);</span><br><span class="line">        head.next = reverseKGroup(l2,k);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转[m,n)之间的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode m,ListNode n)</span></span>&#123;</span><br><span class="line">        ListNode dumy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = m;</span><br><span class="line">        <span class="keyword">while</span>(cur != n)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = dumy.next;</span><br><span class="line">            dumy.next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目概述&quot;&gt;&lt;a href=&quot;#题目概述&quot; class=&quot;headerlink&quot; title=&quot;题目概述&quot;&gt;&lt;/a&gt;题目概述&lt;/h1&gt;&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc69-实现Sqrt(x)</title>
    <link href="http://example.com/2021/10/09/Lc69-%E5%AE%9E%E7%8E%B0Sqrt-x/"/>
    <id>http://example.com/2021/10/09/Lc69-%E5%AE%9E%E7%8E%B0Sqrt-x/</id>
    <published>2021-10-09T13:09:45.000Z</published>
    <updated>2021-10-09T13:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="number">8</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">8</span> 的算术平方根是 <span class="number">2.82842</span>..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>通过二分法，比较mid * mid 和 x的关系从而缩小范围</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个非负整数 x ，计算并返回 x 的 算术平方根 。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留 整数部分 ，小数部</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc42-接雨水</title>
    <link href="http://example.com/2021/10/08/Lc42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://example.com/2021/10/08/Lc42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2021-10-08T01:00:21.000Z</published>
    <updated>2021-10-08T01:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/pic/%E6%8E%A5%E9%9B%A8%E6%B0%B4.png" alt="image-20211008090207593"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>维护两个变量left_max,right_max分别记录左侧柱子最大值和右侧柱子最大值</li><li>维护两个指针，向中间遍历</li><li>如果左指针代表的柱子高度小于右指针所带表柱子高度，则使用左指针计算(木桶原理)</li><li>将计算的结构加入到之前统计的雨水量中</li></ol><p>Coding</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            left_max = Math.max(left_max,height[left]);</span><br><span class="line">            right_max = Math.max(right_max,height[right]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                res += left_max - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += right_max - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc32-最长有小括号</title>
    <link href="http://example.com/2021/10/08/Lc32-%E6%9C%80%E9%95%BF%E6%9C%89%E5%B0%8F%E6%8B%AC%E5%8F%B7/"/>
    <id>http://example.com/2021/10/08/Lc32-%E6%9C%80%E9%95%BF%E6%9C%89%E5%B0%8F%E6%8B%AC%E5%8F%B7/</id>
    <published>2021-10-08T00:14:00.000Z</published>
    <updated>2021-10-08T00:20:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(()&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">&quot;()&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;)()())&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">&quot;()()&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>维护一个栈，栈底存放最后一个不合法的右括号</li><li>遇到左括号进行入栈</li><li>遇到右括号弹栈<ol><li>如果此时栈为空，说明当前右括号不合法，因此，将当前右括号下标入栈</li><li>栈不为空，说明该右括号合法，只需要计算长度即可</li></ol></li><li>每次计算，统计最大值</li></ol><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    len = Math.max(len,i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个只包含 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt; 的字</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc补充-圆环回原点</title>
    <link href="http://example.com/2021/10/08/Lc%E8%A1%A5%E5%85%85-%E5%9C%86%E7%8E%AF%E5%9B%9E%E5%8E%9F%E7%82%B9/"/>
    <id>http://example.com/2021/10/08/Lc%E8%A1%A5%E5%85%85-%E5%9C%86%E7%8E%AF%E5%9B%9E%E5%8E%9F%E7%82%B9/</id>
    <published>2021-10-07T23:07:00.000Z</published>
    <updated>2021-10-07T23:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释：有<span class="number">2</span>种方案。分别是<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span>和<span class="number">0</span>-&gt;<span class="number">9</span>-&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li><p>动态规划的思想</p></li><li><p>状态：</p><ol><li>某个点</li><li>步数</li></ol></li><li><p>状态转移方程</p><p> dp[i][j] = dp[i - 1][(j - 1 + length) % length] + dp[i - 1][(j + 1) % length];</p></li><li><p>状态解释:从某个点走到0无非就是从9 -&gt; 0,和从1 -&gt; 0两种情况，从9 -&gt; 0只需要到9位置处在向前走 1步就可以，从1 -&gt; 0，只需要从1点往回走1步</p></li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backToOrigin</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">10</span>;<span class="comment">//0 - 9 10个点</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; length;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][(j - <span class="number">1</span> + length) % length] + dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % length];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc143:重排链表</title>
    <link href="http://example.com/2021/10/07/Lc143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/10/07/Lc143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</id>
    <published>2021-10-07T13:33:27.000Z</published>
    <updated>2021-10-07T13:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p><p> L0 → L1 → … → Ln-1 → Ln<br>请将其重新排列后变为：</p><p>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</p><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/pic/lc143.png" alt="image-20211007213445816"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><ul><li>链表的长度范围为 <code>[1, 5 * 104]</code></li><li><code>1 &lt;= node.val &lt;= 1000</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>找到链表中点<ol><li>通过快慢指针,快指针每次走两步，慢指针每次走一步</li><li>当快指针为空或快指针下一个节点为空时，慢节点所在位置即为链表中点</li><li>当链表为偶数时，慢指针所在位置为中点靠后的位置</li></ol></li><li>将链表按中点分为两部分，记为A,B</li><li>对后半部分进行反转</li><li>对两块链表做归并操作<ol><li>分别记录两链表next指针位置,A_next = A.next,B_next = B.next</li><li>A.next = B,A = A_next</li><li>B.next = A,B = B_next</li></ol></li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到链表中点</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将中间节点右侧节点反转</span></span><br><span class="line">        ListNode tem = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode newHead = reverse(tem);</span><br><span class="line">        <span class="comment">//元素交换</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; newHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode l1_next = cur.next;</span><br><span class="line">            ListNode l2_next = newHead.next;</span><br><span class="line"></span><br><span class="line">            cur.next = newHead;</span><br><span class="line">            cur = l1_next;</span><br><span class="line">            newHead.next = cur;</span><br><span class="line">            newHead = l2_next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个单链表 L 的头节点 head ，单链表 L 表示为：&lt;/p&gt;
&lt;p&gt; L0 → L1 → … → Ln-1 → L</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lc31:下一个排列</title>
    <link href="http://example.com/2021/10/07/Lc31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://example.com/2021/10/07/Lc31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2021-10-07T13:06:54.000Z</published>
    <updated>2021-10-07T13:31:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>从len(nums) - 2处倒序遍历数组找到第一个nums[i] &lt; nums[i + 1]的数,记为target</li><li>判断该数位置是否合法</li><li>从len(nums) - 1处倒序遍历数组，找到第一个比target大的数字</li><li>交换两个数字</li><li>对i+1后面的数进行升序排列，因为i+1后面的数是4 3 2 1这种递减排列的，因此直接reverse即可升序</li><li>即可满足比原排列较大</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end= nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            exch(nums,start,end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。&lt;/p</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Reactor模型</title>
    <link href="http://example.com/2021/09/29/Reactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/09/29/Reactor%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-09-29T05:41:45.000Z</published>
    <updated>2021-09-29T06:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程。</p><p>其实创建进程也是可以的，原理是一样的，进程和线程的区别在于线程比较轻量级些，线程的创建和线程间切换的成本要小些，为了描述简述，后面都以线程为例。</p><p>处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的。</p><p>要这么解决这个问题呢？我们可以使用「资源复用」的方式。</p><p>也就是不用再为每个连接创建线程，而是创建一个「线程池」，将连接分配给线程，然后一个线程可以处理多个连接的业务。</p><p>不过，这样又引来一个新的问题，线程怎样才能高效地处理多个连接的业务？</p><p>当一个连接对应一个线程时，线程一般采用「read -&gt; 业务处理 -&gt; send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 <code>read</code> 操作上（ socket 默认情况是阻塞 I/O），不过这种阻塞方式并不影响其他线程。</p><p>但是引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的<code>read</code> 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务。</p><p>要解决这一个问题，最简单的方式就是将 socket 改成非阻塞，然后线程不断地轮询调用 <code>read</code> 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低。</p><p>上面的问题在于，线程并不知道当前连接是否有数据可读，从而需要每次通过 <code>read</code>去试探。</p><p>那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I/O 多路复用。</p><p>I/O 多路复用技术会用一个系统调用函数来监听我们所有关心的连接，也就说可以在一个监控线程里面监控很多的连接。</p><p>我们熟悉的 select/poll/epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。</p><blockquote><p>select/poll/epoll 是如何获取网络事件的呢？</p></blockquote><p>在获取事件时，先把我们要关心的连接传给内核，再由内核检测：</p><ul><li>如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面的线程池方案那样轮训调用 read 操作来判断是否有数据。</li><li>如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。</li></ul><p>Reactor 模式也叫 <code>Dispatcher</code> 模式，我觉得这个名字更贴合该模式的含义，即 <strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程</strong>。</p><p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p><ul><li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li><li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li></ul><p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p><ul><li>Reactor 的数量可以只有一个，也可以有多个；</li><li>处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；</li></ul><p>将上面的两个因素排列组设一下，理论上就可以有 4 种方案选择：</p><ul><li>单 Reactor 单进程 / 线程；</li><li>单 Reactor 多进程 / 线程；</li><li>多 Reactor 单进程 / 线程；</li><li>多 Reactor 多进程 / 线程；</li></ul><p>其中，「多 Reactor 单进程 / 线程」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。</p><p>剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中：</p><ul><li>单 Reactor 单进程 / 线程；</li><li>单 Reactor 多线程 / 进程；</li><li>多 Reactor 多进程 / 线程；</li></ul><p>方案具体使用进程还是线程，要看使用的编程语言以及平台有关：</p><ul><li>Java 语言一般使用线程，比如 Netty;</li><li>C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。</li></ul><h1 id="单-Reactor-单进程-线程"><a href="#单-Reactor-单进程-线程" class="headerlink" title="单 Reactor 单进程 / 线程"></a>单 Reactor 单进程 / 线程</h1><p><img src="/pic/%E5%8D%95reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.jpg"></p><p>可以看到进程里有 <strong>Reactor、Acceptor、Handler</strong> 这三个对象：</p><ul><li>Reactor 对象的作用是监听和分发事件；</li><li>Acceptor 对象的作用是获取连接；</li><li>Handler 对象的作用是处理业务；</li></ul><p>对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。</p><p>接下来，介绍下「单 Reactor 单进程」这个方案：</p><ul><li>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li><li>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</li><li>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</li><li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li></ul><p>单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。</p><p>但是，这种方案存在 2 个缺点：</p><ul><li>第一个缺点，因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li><li>第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<strong>如果业务处理耗时比较长，那么就造成响应的延迟</strong>；</li></ul><p>所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p><p>Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</p><h1 id="单Reactor多进程"><a href="#单Reactor多进程" class="headerlink" title="单Reactor多进程"></a>单Reactor多进程</h1><p><img src="/pic/%E5%8D%95Reactor%E5%A4%9A%E8%BF%9B%E7%A8%8B.png"></p><p>流程：</p><ul><li>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li><li>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</li><li>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</li></ul><p>上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：</p><ul><li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；</li><li>子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</li></ul><p>单 Reator 多线程的方案优势在于<strong>能够充分利用多核 CPU 的能</strong>，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。</p><p>例如，子线程完成业务处理后，要把结果传递给主线程的 Reactor 进行发送，这里涉及共享数据的竞争。</p><p>要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。</p><h1 id="多-Reactor-多进程-线程"><a href="#多-Reactor-多进程-线程" class="headerlink" title="多 Reactor 多进程 / 线程"></a>多 Reactor 多进程 / 线程</h1><p><img src="/pic/%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png"></p><p>方案详细说明如下：</p><ul><li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept  获取连接，将新的连接分配给某个子线程；</li><li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。</li><li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</li><li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li></ul><p>多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：</p><ul><li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。</li><li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</li></ul><p>大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。</p><p>采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。</p><p>具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程。&lt;/p&gt;
&lt;p&gt;其实创建进程也是可以的，原理是一样的，进程和线程的区</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ闲聊</title>
    <link href="http://example.com/2021/09/23/RocketMQ%E9%97%B2%E8%81%8A/"/>
    <id>http://example.com/2021/09/23/RocketMQ%E9%97%B2%E8%81%8A/</id>
    <published>2021-09-23T01:24:23.000Z</published>
    <updated>2021-09-23T03:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/pic/rmq%E6%9E%B6%E6%9E%84.png" alt="image-20210923092616437"></p><h1 id="消息存储整体架构"><a href="#消息存储整体架构" class="headerlink" title="消息存储整体架构"></a>消息存储整体架构</h1><h2 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h2><p>​    消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G, 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p><h2 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h2><p>​    消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。consumequeue文件可以看成是基于topic的commitlog索引文件</p><h2 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h2><p>​    提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME \store\index${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p><p>​    RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p><h2 id="页缓存与内存映射"><a href="#页缓存与内存映射" class="headerlink" title="页缓存与内存映射"></a>页缓存与内存映射</h2><p>​    页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取</p><p>​    在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p><p>​    另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p><h2 id="消息刷盘"><a href="#消息刷盘" class="headerlink" title="消息刷盘"></a>消息刷盘</h2><ul><li> 同步刷盘:只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。</li><li> 异步刷盘:能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</li></ul><h1 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h1><p>RocketMQ消息队列集群主要包括NameServer、Broker(Master/Slave)、Producer、Consumer4个角色，基本通讯流程如下：</p><p>(1) Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息。</p><p>(2) 消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有则更新路由信息会从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息。</p><p>(3) 消息生产者Producer根据2）中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</p><p>(4) 消息消费者Consumer根据2）中获取的路由信息，并再完成客户端的负载均衡后，选择其中的某一个或者某几个消息队列来拉取消息并进行消费。</p><p>从上面1）~3）中可以看出在消息生产者, Broker和NameServer之间都会发生通信（这里只说了MQ的部分通信），因此如何设计一个良好的网络通信模块在MQ中至关重要，它将决定RocketMQ集群整体的消息传输能力与最终的性能。</p><p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p><h2 id="消息的通信方式和流程"><a href="#消息的通信方式和流程" class="headerlink" title="消息的通信方式和流程"></a>消息的通信方式和流程</h2><p>在RocketMQ消息队列中支持通信的方式主要有同步(sync)、异步(async)、单向(oneway) 三种。其中“单向”通信模式相对简单，一般用在发送心跳包场景下，无需关注其Response。</p><h2 id="Reactor多线程设计"><a href="#Reactor多线程设计" class="headerlink" title="Reactor多线程设计"></a>Reactor多线程设计</h2><p>RocketMQ的RPC通信采用Netty组件作为底层通信库，同样也遵循了Reactor多线程模型，同时又在这之上做了一些扩展和优化</p><p><img src="/pic/rmq_reactor%E6%A8%A1%E5%9E%8B.png" alt="image-20210923100353907"></p><p>上面的框图中可以大致了解RocketMQ中NettyRemotingServer的Reactor 多线程模型。一个 Reactor 主线程（eventLoopGroupBoss，即为上面的1）负责监听 TCP网络连接请求，建立好连接，创建SocketChannel，并注册到selector上。RocketMQ的源码中会自动根据OS的类型选择NIO和Epoll，也可以通过参数配置）,然后监听真正的网络数据。拿到网络数据后，再丢给Worker线程池（eventLoopGroupSelector，即为上面的“N”，源码中默认设置为3），在真正执行业务逻辑之前需要进行SSL验证、编解码、空闲检查、网络连接管理，这些工作交给defaultEventExecutorGroup（即为上面的“M1”，源码中默认设置为8）去做。而处理业务操作放在业务线程池中执行，根据 RomotingCommand 的业务请求码code去processorTable这个本地缓存变量中找到对应的 processor，然后封装成task任务后，提交给对应的业务processor处理线程池来执行（sendMessageExecutor，以发送消息为例，即为上面的 “M2”）。从入口到业务逻辑的几个步骤中线程池一直再增加，这跟每一步逻辑复杂性相关，越复杂，需要的并发通道越宽。</p><h1 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h1><p>​    RocketMQ分布式消息队列的消息过滤方式有别于其它MQ中间件，是在Consumer端订阅消息时再做消息过滤的。RocketMQ这么做是在于其Producer端写入消息和Consumer端订阅消息采用分离存储的机制来实现的，Consumer端订阅消息是需要通过ConsumeQueue这个消息消费的逻辑队列拿到一个索引，然后再从CommitLog里面读取真正的消息实体内容，所以说到底也是还绕不开其存储结构。其ConsumeQueue的存储结构如下，可以看到其中有8个字节存储的Message Tag的哈希值，基于Tag的消息过滤正是基于这个字段值的。</p><p>​    主要支持如下2种的过滤方式 (1) Tag过滤方式：Consumer端在订阅消息时除了指定Topic还可以指定TAG，如果一个消息有多个TAG，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个 SubscriptionData，发送一个Pull消息的请求给Broker端。Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。</p><p>​    SQL92的过滤方式：这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的 SQL expression 的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以RocketMQ使用了BloomFilter避免了每次都去执行。SQL92的表达式上下文为消息的属性。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>​    RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。</p><h2 id="Producer的负载均衡"><a href="#Producer的负载均衡" class="headerlink" title="Producer的负载均衡"></a>Producer的负载均衡</h2><p>​    Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。具体的容错策略均在MQFaultStrategy这个类中定义。这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p><h2 id="Consumer的负载均衡"><a href="#Consumer的负载均衡" class="headerlink" title="Consumer的负载均衡"></a>Consumer的负载均衡</h2><p>在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端在知道从Broker端的哪一个消息队列—队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p><p>1、Consumer端的心跳包发送</p><p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p><p>2、Consumer端实现负载均衡的核心类—RebalanceImpl</p><p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，该方法是实现Consumer端负载均衡的核心。这里，rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p><p>(1) 从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p><p>(2) 根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取该消费组下消费者Id列表的RPC通信请求（Broker端基于前面Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP）；</p><p>(3) 先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</p><p>(4) 然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p><h1 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h1><p>Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示</p><p><img src="/pic/rnq_tran_mes.png" alt="image-20210923110847452"></p><h2 id="RocketMQ事务消息流程概要"><a href="#RocketMQ事务消息流程概要" class="headerlink" title="RocketMQ事务消息流程概要"></a>RocketMQ事务消息流程概要</h2><p>1.事务消息发送及提交：</p><p>(1) 发送消息（half消息）。</p><p>(2) 服务端响应消息写入结果。</p><p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p><p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p><p>2.补偿流程：</p><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p><p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p><p>(3) 根据本地事务状态，重新Commit或者Rollback</p><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><h2 id="RocketMQ事务消息设计"><a href="#RocketMQ事务消息设计" class="headerlink" title="RocketMQ事务消息设计"></a>RocketMQ事务消息设计</h2><p>1.事务消息在一阶段对用户不可见</p><p>在RocketMQ事务消息的主要流程中，一阶段的消息如何对用户不可见。其中，事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p><p>在RocketMQ中，消息在服务端的存储结构如下，每条消息都会有对应的索引信息，Consumer通过ConsumeQueue这个二级索引来读取消息实体内容，其流程如下：</p><p><img src="/pic/rmq_trac_%E6%9E%B6%E6%9E%84.png" alt="image-20210923111210160"></p><p>RocketMQ的具体实现策略是：写入的如果事务消息，对消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息的属性中，正因为消息主题被替换，故消息并不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费。其实改变消息主题是RocketMQ的常用“套路”，回想一下延时消息的实现机制。</p><p>2.Commit和Rollback操作以及Op消息的引入</p><p>在完成一阶段写入一条对用户不可见的消息后，二阶段如果是Commit操作，则需要让消息对用户可见；如果是Rollback则需要撤销一阶段的消息。先说Rollback的情况。对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。但是区别于这条消息没有确定状态（Pending状态，事务悬而未决），需要一个操作来标识这条消息的最终状态。RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息已经确定的状态（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。</p><p>3.Op消息的存储和对应关系</p><p>RocketMQ将Op消息写入到全局一个特定的Topic中通过源码中的方法—TransactionalMessageUtil.buildOpTopic()；这个Topic是一个内部的Topic（像Half消息的Topic一样），不会被用户消费。Op消息的内容为对应的Half消息的存储的Offset，这样通过Op消息能索引到Half消息进行后续的回查操作。</p><p>4.Half消息的索引构建</p><p>在执行二阶段Commit操作时，需要构建出Half消息的索引。一阶段的Half消息由于是写到一个特殊的Topic，所以二阶段构建索引时需要读取出Half消息，并将Topic和Queue替换成真正的目标的Topic和Queue，之后通过一次普通消息的写入操作来生成一条对用户可见的消息。所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。</p><p>5.如何处理二阶段失败的消息？</p><p>如果在RocketMQ事务消息的二阶段过程中失败了，例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。RocketMQ采用了一种补偿机制，称为“回查”。Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。</p><p>值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</p><h1 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h1><p>​    RocketMQ支持按照下面两种维度（“按照Message Id查询消息”、“按照Message Key查询消息”）进行消息查询。</p><h2 id="按照MessageId查询消息"><a href="#按照MessageId查询消息" class="headerlink" title="按照MessageId查询消息"></a>按照MessageId查询消息</h2><p>​    RocketMQ中的MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口），消息Commit Log offset。“按照MessageId查询消息”在RocketMQ中具体做法是：Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。</p><h2 id="按照Message-Key查询消息"><a href="#按照Message-Key查询消息" class="headerlink" title="按照Message Key查询消息"></a>按照Message Key查询消息</h2><p>“按照Message Key查询消息”，主要是基于RocketMQ的IndexFile索引文件来实现的。RocketMQ的索引文件逻辑结构，类似JDK中HashMap的实现。索引文件的具体结构如下：</p><p><img src="/pic/rmq%E6%B6%88%E6%81%AF%E6%9F%A5%E8%AF%A2.png" alt="image-20210923112824609"></p><p>IndexFile索引文件为用户提供通过“按照Message Key查询消息”的消息索引查询服务，IndexFile文件的存储位置是：$HOME\store\index${fileName}，文件名fileName是以创建时的时间戳命名的，文件大小是固定的，等于40+500W<em>4+2000W</em>20= 420000040个字节大小。如果消息的properties中设置了UNIQ_KEY这个属性，就用 topic + “#” + UNIQ_KEY的value作为 key 来做写入操作。如果消息设置了KEYS属性（多个KEY以空格分隔），也会用 topic + “#” + KEY 来做索引。</p><p>其中的索引数据包含了Key Hash/CommitLog Offset/Timestamp/NextIndex offset 这四个字段，一共20 Byte。NextIndex offset 即前面读出来的 slotValue，如果有 hash冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来了。Timestamp记录的是消息storeTimestamp之间的差，并不是一个绝对的时间。整个Index File的结构如图，40 Byte 的Header用于保存一些总的统计信息，4<em>500W的 Slot Table并不保存真正的索引数据，而是保存每个槽位对应的单向链表的头。20</em>2000W 是真正的索引数据，即一个 Index File 可以保存 2000W个索引。</p><p>“按照Message Key查询消息”的方式，RocketMQ的具体做法是，主要通过Broker端的QueryMessageProcessor业务处理器来查询，读取消息的过程就是用topic和key找到IndexFile索引文件中的一条记录，根据其中的commitLog offset从CommitLog文件中读取消息的实体内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/pic/rmq%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;image-20210923092616437&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;消息存储整体架构&quot;&gt;&lt;a href=&quot;#消息存储整体架构&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Kafka闲聊</title>
    <link href="http://example.com/2021/09/21/Kafka%E9%97%B2%E8%81%8A/"/>
    <id>http://example.com/2021/09/21/Kafka%E9%97%B2%E8%81%8A/</id>
    <published>2021-09-21T03:50:27.000Z</published>
    <updated>2021-09-21T04:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈Kafka设计"><a href="#浅谈Kafka设计" class="headerlink" title="浅谈Kafka设计"></a>浅谈Kafka设计</h1><ol><li>Kafka 将消息以 topic 为单位进行归纳</li><li>将向 Kafka topic 发布消息的程序称为 producers</li><li>将预订 topics 并消费消息的程序成为 consumer</li><li>Kafka 以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 broker.</li><li>producers 通过网络将消息发送到 Kafka 集群，集群向消费者提供消息</li></ol><h1 id="Kafka如何保证高可用"><a href="#Kafka如何保证高可用" class="headerlink" title="Kafka如何保证高可用"></a>Kafka如何保证高可用</h1><p>Kafka 的基本架构组成是：由多个 broker 组成一个集群，每个 broker 是一个节点；当创建一个topic 时，这个 topic 会被划分为多个 partition ，每个 partition 可以存在于不同的 broker上，每个 partition 只存放一部分数据。</p><p>这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据</p><p>在 Kafka 0.8 版本之前，是没有 HA 机制的，当任何一个 broker 所在节点宕机了，这个 broker 上 的 partition 就无法提供读写服务，所以这个版本之前， Kafka 没有什么高可用性可言</p><p>在 Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 上的数据都会同步到其它机器，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，消息的生产者和消费者都跟这个 leader 打交道，其他 replica 作为 follower 。写的时候， leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。 Kafka 负责均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p><img src="/pic/Kafka%E6%9E%B6%E6%9E%84.png" alt="image-20210921120525433"></p><p>拥有了 replica 副本机制，如果某个 broker 宕机了，这个 broker 上的 partition 在其他机器上还存在副本。如果这个宕机的 broker 上面有某个 partition 的 leader ，那么此时会从其follower 中重新选举一个新的 leader 出来，这个新的 leader 会继续提供读写服务，这就有达到了所谓的高可用性</p><p>写数据的时候，生产者只将数据写入 leader 节点， leader 会将数据写入本地磁盘，接着其他follower 会主动从 leader 来拉取数据， follower 同步好数据了，就会发送 ack 给 leader ， leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。消费数据的时候，消费者只会从 leader 节点去读取消息，但是只有当一个消息已经被所有 follower都同步成功返回 ack 的时候，这个消息才会被消费者读到</p><p><img src="/pic/kafka%E6%9E%B6%E6%9E%842.png" alt="image-20210921120651307"></p><h1 id="Kafka-消息是采用-Pull-模式，还是-Push-模式"><a href="#Kafka-消息是采用-Pull-模式，还是-Push-模式" class="headerlink" title="Kafka 消息是采用 Pull 模式，还是 Push 模式"></a><strong>Kafka</strong> 消息是采用 <strong>Pull</strong> 模式，还是 <strong>Push</strong> 模式</h1><p>生产者使用push模式将消息发布到Broker，消费者使用pull模式从Broker订阅消息。</p><p>push模式很难适应消费速率不同的消费者，如果push的速度太快，容易造成消费者拒绝服务或网络拥塞；如果push的速度太慢，容易造成消费者性能浪费。但是采用pull的方式也有一个缺点，就是当Broker没有消息时，消费者会陷入不断地轮询中，为了避免这点，kafka有个参数可以让消费者阻塞知道是否有新消息到达</p><h1 id="什么是消费者组"><a href="#什么是消费者组" class="headerlink" title="什么是消费者组"></a>什么是消费者组</h1><p>消费者组是Kafka独有的概念，即消费者组是Kafka提供的可扩展且具有容错性的消费者机制。</p><p>但实际上，消费者组（Consumer Group）其实包含两个概念，作为队列，消费者组允许你分割数据处理到一组进程集合上（即一个消费者组中可以包含多个消费者进程，他们共同消费该topic的数据），这有助于你的消费能力的动态调整；作为发布-订阅模型（publish-subscribe），Kafka允许你将同一份消息广播到多个消费者组里，以此来丰富多种数据使用场景。需要注意的是：在消费者组中，多个实例共同订阅若干个主题，实现共同消费。同一个组下的每个实例都配置有相同的组ID，被分配不同的订阅分区。当某个实例挂掉的时候，其他实例会自动地承担起它负责消费的分区。 因此，消费者组在一定程度上也保证了消费者程序的高可用性。</p><h2 id="在Kafka中，ZooKeeper的作用是什么"><a href="#在Kafka中，ZooKeeper的作用是什么" class="headerlink" title="在Kafka中，ZooKeeper的作用是什么"></a>在<strong>Kafka</strong>中，<strong>ZooKeeper</strong>的作用是什么</h2><p>目前，Kafka使用ZooKeeper存放集群元数据、成员管理、Controller选举，以及其他一些管理类任务。之后，等KIP-500提案完成后，Kafka将完全不再依赖于ZooKeeper</p><ul><li><p>“存放元数据”是指主题分区的所有数据都保存在 ZooKeeper 中，且以它保存的数据为权威，其他</p><p>“人” 都要与它保持对齐。</p></li><li><p>“成员管理” 是指 Broker 节点的注册、注销以及属性变更，等等</p></li><li><p>“Controller 选举” 是指选举集群 Controller，而其他管理类任务包括但不限于主题删除、参数配置</p><p>等。</p></li></ul><h1 id="Kafka中位移（offset）的作用"><a href="#Kafka中位移（offset）的作用" class="headerlink" title="Kafka中位移（offset）的作用"></a><strong>Kafka</strong>中位移（<strong>offset</strong>）的作用</h1><p>在Kafka中，每个主题分区下的每条消息都被赋予了一个唯一的ID数值，用于标识它在分区中的位置。这个ID数值，就被称为位移，或者叫偏移量。一旦消息被写入到分区日志，它的位移值将不能被修改。</p><h1 id="kafka-producer发送数据，ack为0，1，-1分别是什么意思"><a href="#kafka-producer发送数据，ack为0，1，-1分别是什么意思" class="headerlink" title="kafka producer发送数据，ack为0，1，-1分别是什么意思"></a>kafka producer<strong>发送数据，</strong>ack<strong>为</strong>0<strong>，</strong>1<strong>，</strong>-1分别是什么意思</h1><ul><li><p><code>1 </code>（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种</p><p>情况下，如果leader宕机了，则会丢失数据。</p></li><li><p><code>0</code>生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据</p><p>可靠性确是最低的。</p></li><li><p><code>-1</code> producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。</p><p>当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请</p><p>求中的消息都commit了。</p></li></ul><h1 id="Kafka如何保证消息不丢失"><a href="#Kafka如何保证消息不丢失" class="headerlink" title="Kafka如何保证消息不丢失"></a><strong>Kafka</strong>如何保证消息不丢失</h1><blockquote><p>消息丢失的原因</p></blockquote><p>对于一个消息队列，会有 生产者 、 MQ 、 消费者 这三个角色，在这三个角色数据处理和传输过程中，都有可能会出现消息丢失</p><h2 id="消费者异常导致的消息丢失"><a href="#消费者异常导致的消息丢失" class="headerlink" title="消费者异常导致的消息丢失"></a>消费者异常导致的消息丢失</h2><p>消费者可能导致数据丢失的情况是：消费者获取到了这条消息后，还未处理， Kafka 就自动提交了offset ，这时 Kafka 就认为消费者已经处理完这条消息，其实消费者才刚准备处理这条消息，这时如果消费者宕机，那这条消息就丢失了。消费者引起消息丢失的主要原因就是消息还未处理完 Kafka 会自动提交了 offset ，那么只要关闭自动提交 offset ，消费者在处理完之后手动提交 offset ，就可以保证消息不会丢失。但是此时需要注意重复消费问题，比如消费者刚处理完，还没提交 offset ，这时自己宕机了，此时这条消息肯定会被重复消费一次，这就需要消费者根据实际情况保证幂等性。</p><h2 id="生产者数据传输导致的消息丢失"><a href="#生产者数据传输导致的消息丢失" class="headerlink" title="生产者数据传输导致的消息丢失"></a>生产者数据传输导致的消息丢失</h2><p>对于生产者数据传输导致的数据丢失主常见情况是生产者发送消息给 Kafka ，由于网络等原因导致消息丢失，对于这种情况也是通过在 <strong>producer</strong> 端设置 <strong>acks=all</strong> 来处理，这个参数是要求 leader 接收到消息后，需要等到所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试。</p><h2 id="broker导致的消息丢失"><a href="#broker导致的消息丢失" class="headerlink" title="broker导致的消息丢失"></a>broker导致的消息丢失</h2><p>Kafka 导致的数据丢失一个常见的场景就是 Kafka 某个 broker 宕机，，而这个节点正好是某个partition 的 leader 节点，这时需要重新重新选举该 partition 的 leader 。如果该 partition 的 leader 在宕机时刚好还有些数据没有同步到 follower ，此时 leader 挂了，在选举某个follower 成 leader 之后，就会丢失一部分数据。</p><p>Kafka 可以设置如下 4 个参数，来尽量避免消息丢失：</p><ul><li><p>给 topic 设置 replication.factor 参数：这个值必须大于 1 ，要求每个 partition 必须有</p><p>至少 2 个副本</p></li><li><p>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1 ，这个参数的含义是一个leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader挂了还有一个 follower 节点</p></li><li><p>在 producer 端设置 acks=all ，这个是要求每条数据，必须是写入所有 replica 之后，才能认</p><p>为是写成功了；</p></li><li><p>在 producer 端设置 retries=MAX （很大很大很大的一个值，无限次重试的意思）：这个参数的</p><p>含义是一旦写入失败，就无限重试，卡在这里了。</p></li></ul><h1 id="Kafka-如何保证消息的顺序性"><a href="#Kafka-如何保证消息的顺序性" class="headerlink" title="Kafka 如何保证消息的顺序性"></a><strong>Kafka</strong> 如何保证消息的顺序性</h1><p>在某些业务场景下，我们需要保证对于有逻辑关联的多条MQ消息被按顺序处理，比如对于某一条数据，正常处理顺序是 新增-更新-删除 ，最终结果是数据被删除；如果消息没有按序消费，处理顺序可能是 删除-新增-更新 ，最终数据没有被删掉，可能会产生一些逻辑错误。对于如何保证消息的顺序性，主要需要考虑如下两点：</p><ul><li>如何保证消息在 Kafka 中顺序性</li><li>如何保证消费者处理消费的顺序性</li></ul><h2 id="如何保证消息在-Kafka-中顺序性"><a href="#如何保证消息在-Kafka-中顺序性" class="headerlink" title="如何保证消息在 Kafka 中顺序性"></a>如何保证消息在 <strong>Kafka</strong> 中顺序性</h2><p>对于 Kafka ，如果我们创建了一个 topic ，默认有三个 partition 。生产者在写数据的时候，可以指定一个 key ，比如在订单 topic 中我们可以指定订单 id 作为 key ，那么相同订单 id 的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从partition 中取出来数据的时候，也一定是有顺序的。通过制定 key 的方式首先可以保证在 kafka内部消息是有序的。</p><h2 id="如何保证消费者处理消费的顺序性"><a href="#如何保证消费者处理消费的顺序性" class="headerlink" title="如何保证消费者处理消费的顺序性"></a>如何保证消费者处理消费的顺序性</h2><p>对于某个 topic 的一个 partition ，只能被同组内部的一个 consumer 消费，如果这个 consumer内部还是单线程处理，那么其实只要保证消息在 MQ 内部是有顺序的就可以保证消费也是有顺序的。但是单线程吞吐量太低，在处理大量 MQ 消息时，我们一般会开启多线程消费机制，那么如何保证消息在多个线程之间是被顺序处理的呢？对于多线程消费我们可以预先设置 N 个内存 Queue ，具有相同 key的数据都放到同一个内存 Queue 中；然后开启 N 个线程，每个线程分别消费一个内存 Queue 的数据即可，这样就能保证顺序性。当然，消息放到内存 Queue 中，有可能还未被处理， consumer 发生宕机，内存 Queue 中的数据会全部丢失，这就转变为上面提到的如何保证消息的可靠传输的问题了</p><h1 id="Kafka的哪些场景中使用了零拷贝"><a href="#Kafka的哪些场景中使用了零拷贝" class="headerlink" title="Kafka的哪些场景中使用了零拷贝"></a><strong>Kafka</strong>的哪些场景中使用了零拷贝</h1><p>在Kafka中，体现Zero Copy使用场景的地方有两处：基于mmap的索引和日志文件读写所用的TransportLayer。先说第一个。索引都是基于MappedByteBuffer的，也就是让用户态和内核态共享内核态的数据缓冲区，此时，数据不需要复制到用户态空间。不过，mmap虽然避免了不必要的拷贝，但不一定就能保证很高的性能。在不同的操作系统下，mmap的创建和销毁成本可能是不一样的。很高的创建和销毁开销会抵消Zero Copy带来的性能优势。由于这种不确定性，在Kafka中，只有索引应用了mmap，最核心的日志并未使用mmap机制。再说第二个。TransportLayer是Kafka传输层的接口。它的某个实现类使用了FileChannel的transferTo方法。该方法底层使用sendfile实现了Zero Copy。对Kafka而言，如果I/O通道使用普通的PLAINTEXT，那么，Kafka就可以利用Zero Copy特性，直接将页缓存中的数据发送到网卡的Buffer中，避免中间的多次拷贝。相反，如果I/O通道启用了SSL，那么，Kafka便无法利用Zero Copy特性了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浅谈Kafka设计&quot;&gt;&lt;a href=&quot;#浅谈Kafka设计&quot; class=&quot;headerlink&quot; title=&quot;浅谈Kafka设计&quot;&gt;&lt;/a&gt;浅谈Kafka设计&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Kafka 将消息以 topic 为单位进行归纳&lt;/li&gt;
&lt;li&gt;将向</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
