<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java后端基础复习---Java语言基础 | Alan_</title><meta name="keywords" content="Java语言基础"><meta name="author" content="Alan_"><meta name="copyright" content="Alan_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="一. Java语言基础1.1.面向对象的三大特征？1.1.1 封装 将描述实体的数据和基于这些实体数据的操作集合到一起，形成一个封装体、  封装的思想保证了类内部数据结构的完整性，使用户无法轻易直接操作类的内部数据，降低了对内部数据的影响，提高了程序的安全性和可维护性。    封装的好处？   只能通过规定的方法访问数据 隐藏类的实现细节 方便修改   this关键字 ?   this 指代当前对">
<meta property="og:type" content="article">
<meta property="og:title" content="Java后端基础复习---Java语言基础">
<meta property="og:url" content="http://example.com/2020/10/14/Java%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Alan_">
<meta property="og:description" content="一. Java语言基础1.1.面向对象的三大特征？1.1.1 封装 将描述实体的数据和基于这些实体数据的操作集合到一起，形成一个封装体、  封装的思想保证了类内部数据结构的完整性，使用户无法轻易直接操作类的内部数据，降低了对内部数据的影响，提高了程序的安全性和可维护性。    封装的好处？   只能通过规定的方法访问数据 隐藏类的实现细节 方便修改   this关键字 ?   this 指代当前对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-10-14T09:28:19.000Z">
<meta property="article:modified_time" content="2021-03-27T07:38:24.000Z">
<meta property="article:author" content="Alan_">
<meta property="article:tag" content="Java语言基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="http://example.com/2020/10/14/Java%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-27 15:38:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Alan_" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">94</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Alan_</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Java后端基础复习---Java语言基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-14T09:28:19.000Z" title="发表于 2020-10-14 17:28:19">2020-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-27T07:38:24.000Z" title="更新于 2021-03-27 15:38:24">2021-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">Java语言基础</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一-Java语言基础"><a href="#一-Java语言基础" class="headerlink" title="一. Java语言基础"></a>一. Java语言基础</h1><h2 id="1-1-面向对象的三大特征？"><a href="#1-1-面向对象的三大特征？" class="headerlink" title="1.1.面向对象的三大特征？"></a>1.1.面向对象的三大特征？</h2><h3 id="1-1-1-封装"><a href="#1-1-1-封装" class="headerlink" title="1.1.1 封装"></a>1.1.1 封装</h3><ol>
<li><p>将描述实体的数据和基于这些实体数据的操作集合到一起，形成一个封装体、</p>
</li>
<li><p>封装的思想保证了类内部数据结构的完整性，使用户无法轻易直接操作类的内部数据，降低了对内部数据的影响，提高了程序的安全性和可维护性。</p>
</li>
</ol>
<blockquote>
<p>封装的好处？</p>
</blockquote>
<ul>
<li>只能通过规定的方法访问数据</li>
<li>隐藏类的实现细节</li>
<li>方便修改</li>
</ul>
<blockquote>
<p>this关键字 ?</p>
</blockquote>
<ul>
<li>this 指代当前对象</li>
<li>this 调用本类中的构造方法，调用时要放在构造方法的首行，因此 this 和 super只可出现其一。</li>
<li>this 关键字不可再static代码块中使用，因为静态代码块初始化时，对象还未创建完成。</li>
</ul>
<h3 id="1-1-2-继承"><a href="#1-1-2-继承" class="headerlink" title="1.1.2 继承"></a>1.1.2 继承</h3><ol>
<li>继承使得类变得具有层次化</li>
<li>继承就是子类继承父类得特征和行为，使得子类对象具有父类的得属性和方法，或从父类继承方法，使得子类与父类具有相同得行为</li>
</ol>
<blockquote>
<p>Java中继承得特点：</p>
</blockquote>
<ul>
<li>Java中的类时单继承多实现的，也就是说一个子类只能继承一个父类，但却可以同时实现多个接口，一个接口可以继承多个接口</li>
<li>父类的构造方法不可被继承，但可以被重写</li>
<li>父类中被private修饰的属性，方法不可被继承</li>
<li>子类通过super关键字去调用父类的属性与方法</li>
</ul>
<blockquote>
<p>super关键字</p>
</blockquote>
<ul>
<li>super关键字只可出现在子类的成员方法与构造方法中</li>
<li>super关键字要放在构造函数的第一行</li>
<li>super关键字不可以访问父类的private成员</li>
</ul>
<h3 id="1-1-3-多态"><a href="#1-1-3-多态" class="headerlink" title="1.1.3 多态"></a>1.1.3 多态</h3><p>多态分为静态多态与动态多态</p>
<ul>
<li>静态多态的具体实现为重载函数，即在编译期就可确定调用的方法</li>
<li>动态多态就是我们常见的那样，父类引用指向子类对象</li>
</ul>
<blockquote>
<p>多态实现方式</p>
</blockquote>
<ul>
<li>子类继承父类</li>
<li>子类重写父类方法</li>
<li>父类引用指向子类对象</li>
</ul>
<p>多态具体原理可见<a target="_blank" rel="noopener" href="https://tonyxb.github.io/2020/09/05/jvm%E7%AC%94%E8%AE%B0-%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%A4%9A%E6%80%81/">多态原理</a></p>
<h2 id="1-2-八种基本数据类型"><a href="#1-2-八种基本数据类型" class="headerlink" title="1.2 八种基本数据类型"></a>1.2 八种基本数据类型</h2><ul>
<li>byte(1个字节)</li>
<li>boolean(1个字节)</li>
<li>short(2个字节)</li>
<li>char(2个字节)</li>
<li>int(4个字节)</li>
<li>float(4个字节)</li>
<li>long(8个字节)</li>
<li>double(8个字节)</li>
</ul>
<h2 id="1-3-重载与重写的区别"><a href="#1-3-重载与重写的区别" class="headerlink" title="1.3 重载与重写的区别"></a>1.3 重载与重写的区别</h2><ul>
<li>重载是方法之间的，方法名相同，但方法的参数表的个数，类型不同构成重载，但返回值类型不能作为方法重载的唯一判断标准，方法的权限修饰符可以相同，也可以不同</li>
<li>重写是指子类/实现类重写父类/接口中的方法，要满足两小，两同，一大原则<ul>
<li>子类方法的权限修饰符大于等于父类方法的权限修饰符，子类重写方法抛出的异常类型不大于父类方法抛出的异常类型</li>
<li>返回值类型必须相同，子类方法的方法名，参数表的参数个数与类型必须与父类方法相同</li>
</ul>
</li>
</ul>
<h2 id="1-4-构造方法"><a href="#1-4-构造方法" class="headerlink" title="1.4 构造方法"></a>1.4 构造方法</h2><ul>
<li>构造方法名必须与类名相同</li>
<li>构造方法可以重载(也就是说一个类可以有多个构造函数，通过参数表的参数个数进行重载)</li>
<li>构造方法没有返回值类型</li>
<li>如果没有显示的给出构造函数，系统会自动插入一个无参的空构造方法</li>
<li>构造方法无法被继承，只能通过super关键字调用</li>
<li>每次调用构造方法都是构造出一个新的对象，因此不会出现多个线程同时读取一个对象中的属性问题，因此不需要加锁</li>
</ul>
<h2 id="1-5-接口与抽象类"><a href="#1-5-接口与抽象类" class="headerlink" title="1.5 接口与抽象类"></a>1.5 接口与抽象类</h2><table>
<thead>
<tr>
<th align="center">接口</th>
<th align="center">抽象类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一个类可以实现多个接口</td>
<td align="center">一个类只能继承一个抽象类</td>
</tr>
<tr>
<td align="center">没有构造方法</td>
<td align="center">可以存在构造方法</td>
</tr>
<tr>
<td align="center">没有普通成员变量</td>
<td align="center">可以有普通成员变量</td>
</tr>
<tr>
<td align="center">静态变量必须用public static final修饰</td>
<td align="center">静态变量可以是任意类型</td>
</tr>
<tr>
<td align="center">Java8之前都是抽象方法，Java8之后可以有默认方法</td>
<td align="center">可以有普通方法</td>
</tr>
<tr>
<td align="center">不可以有静态方法</td>
<td align="center">可存在静态方法</td>
</tr>
<tr>
<td align="center">不能被实例化</td>
<td align="center">不能被实例化</td>
</tr>
</tbody></table>
<h2 id="1-6-Object类的基本方法"><a href="#1-6-Object类的基本方法" class="headerlink" title="1.6 Object类的基本方法"></a>1.6 Object类的基本方法</h2><p>Object类是所有类的超类，因此Object的方法可以被所有类调用</p>
<ol>
<li><strong>Clone</strong> 方法：<ol>
<li>实现对象的浅复制，必须继承Cloneable接口才可使用此方法，否则会抛CloneNotSupportedException异常。</li>
</ol>
</li>
<li>**getClass()**方法：<ol>
<li>获取运行时类型</li>
</ol>
</li>
<li><strong>toString</strong>()方法:<ol>
<li>返回该对象的字符串表示形式</li>
</ol>
</li>
<li>finalize()方法：<ol>
<li>用于释放资源</li>
</ol>
</li>
<li>equals()方法:<ol>
<li>一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</li>
</ol>
</li>
<li>hashCode()方法:<ol>
<li>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</li>
<li>一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</li>
</ol>
</li>
<li>wait()方法:<ol>
<li>使当前线程放弃当前对象的锁，进入到WAITTING状态，调用该方法后当前线程进入睡眠状态，直到以下事件发生。</li>
<li>其他线程调用了该对象的notify()方法</li>
<li>其他线程调用了该对象的notifyAll()方法</li>
<li>其他线程调用了interrupt中断该线程。</li>
<li>时间间隔到了</li>
</ol>
</li>
<li>notify()方法：<ol>
<li>唤醒该对象上某个等待的线程</li>
</ol>
</li>
<li>notifyAll()方法：<ol>
<li>该方法唤醒在该对象上等待的所有线程</li>
</ol>
</li>
</ol>
<h2 id="1-7-final关键字"><a href="#1-7-final关键字" class="headerlink" title="1.7 final关键字"></a>1.7 final关键字</h2><p>final可修饰属性，方法，类。</p>
<ul>
<li>被final修饰的属性是常量，对于基本类型来说，值不可以改变，对于引用数据类型来说，内存地址不可改变.</li>
<li>被final修饰的方法不可被子类重写</li>
<li>被final修饰的类不可被子类继承</li>
</ul>
<h2 id="1-8-静态变量，静态方法，静态代码块"><a href="#1-8-静态变量，静态方法，静态代码块" class="headerlink" title="1.8 静态变量，静态方法，静态代码块"></a>1.8 静态变量，静态方法，静态代码块</h2><ol>
<li><p>静态变量: 被static关键字修饰的变量称为静态变量，静态变量是属于类的，不可在方法中定义静态变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    code..</span><br><span class="line">&#125; 静态代码块优先于主方法执行，且只执行一次</span><br></pre></td></tr></table></figure>


</li>
<li><p>静态方法中不能引用非静态方法和非静态属性—理由很简单，因为静态方法直接可以不经过实例化就可以使用。但是非静态方法必须借助一个实例才能使用。静态方法中没有this指针<br>静态方法可以重载<br>static的方法在装载class得时候首先完成，比 构造方法早，此时非static得和方法还没有完成初始化，所以不能调用。</p>
</li>
<li><p>执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其中涉及：静态初始化代码块、构造代码块、构造方法</span><br><span class="line">当涉及到继承时，按照如下顺序执行：</span><br><span class="line"><span class="number">1</span>、执行父类的静态代码块 </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">输出:<span class="keyword">static</span> A</span><br><span class="line"><span class="number">2</span>、执行子类的静态代码块</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">输出:<span class="keyword">static</span> B</span><br><span class="line"><span class="number">3</span>、执行父类的构造代码块</span><br><span class="line">&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I’m A class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">输出:I<span class="string">&#x27;m A class</span></span><br><span class="line"><span class="string">4、执行父类的构造函数</span></span><br><span class="line"><span class="string">public HelloA() &#123;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">输出：无</span></span><br><span class="line"><span class="string">5、执行子类的构造代码块</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;I’m B class&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">输出:I&#x27;</span>m B <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">6、执行子类的构造函数</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">HelloB</span>() </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">输出：无</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-9-基本数据类型与引用数据类型区别"><a href="#1-9-基本数据类型与引用数据类型区别" class="headerlink" title="1.9 基本数据类型与引用数据类型区别"></a>1.9 基本数据类型与引用数据类型区别</h2><ul>
<li>基本数据类型只能保存一些常量数据</li>
<li>引用数据类型:变量名指向数据存储的那块内存地址</li>
</ul>
<h2 id="2-1-JVM-JRE-JDK-区别"><a href="#2-1-JVM-JRE-JDK-区别" class="headerlink" title="2.1 JVM JRE JDK 区别"></a>2.1 JVM JRE JDK 区别</h2><ul>
<li>JDK：JAVA语言开发工具包，在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。</li>
<li>JRE：包含JVM标准实现和JAVA核心类库，JRE是JAVA运行环境而不是开发环境，不包含任何开发工具（如编译器和调试器）</li>
<li>JVM：JAVA虚拟机，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的</li>
</ul>
<h2 id="2-2-Java变量初始值问题"><a href="#2-2-Java变量初始值问题" class="headerlink" title="2.2 Java变量初始值问题"></a>2.2 Java变量初始值问题</h2><p>成员变量有初始值，局部变量没有初始值，final修饰的变量一定要有初始值</p>
<h2 id="2-3-Java集合类"><a href="#2-3-Java集合类" class="headerlink" title="2.3 Java集合类"></a>2.3 Java集合类</h2><p><img src="C:\Users\16232\AppData\Roaming\Typora\typora-user-images\image-20201014144301561.png" alt="image-20201014144301561"></p>
<h3 id="2-3-1-List"><a href="#2-3-1-List" class="headerlink" title="2.3.1 List"></a>2.3.1 List</h3><h4 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h4><ol>
<li><p>ArrayList内部通过数组实现，允许对元素进行快速随机访问。虽然访问速度很快，但数组这种数据结构缺点也很明显，当数组的大小不满足存储需求时，需要将已有数组赋值到新的数组中。当向ArrayList中间插入元素或者移除元素时，需要对数组进行复制，移动，代价高，因此他更适合查找与遍历，不适合插入和删除。如果需要删除末尾元素，ArrayList的效率很高。</p>
</li>
<li><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default initial capacity.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">从源码中我们不难看出，ArrayList有一个默认的初始容量<span class="number">10</span>，如果在构造函数中我们不给予他默认值，他就会创建一个空的对象数组，在添加元素时会给这个数组默认长度</span><br></pre></td></tr></table></figure>





<blockquote>
<p>put过程源码分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们不难看出，add方法是没有加锁的，也就是说在某一时刻，可以有多个线程执行add方法，会造成线程安全问题，因此ArrayList是线程不安全的，这样设计的目的也是为了提高集合的并发读取能力，解决方式如下:</p>
</li>
</ol>
<ul>
<li>对add方法加锁</li>
<li>使用Collections.sychronizedList()方法，底层是加锁操作，因为是加重量级锁，因此会有性能上的问题</li>
<li>JUC并发包下的CopyOnWriteArrayList()方法，具体原理见JUC并发包。</li>
</ul>
<h4 id="2-LinkList"><a href="#2-LinkList" class="headerlink" title="2. LinkList"></a>2. LinkList</h4><p>LinkList底层使用链表实现，适合数据的动态插入与删除，但随机访问和遍历的速度较慢，另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
<h3 id="2-3-2-Set"><a href="#2-3-2-Set" class="headerlink" title="2..3.2 Set"></a>2..3.2 Set</h3><h4 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h4><ol>
<li>底层采用Hash表实现，HashSet得存储顺序并不是按照插入时得顺序进行存储，而是按照Hash值来进行存储，读取数据的时候也是采用通过获取元素得HashCode来获取。</li>
<li> HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</li>
<li>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；</li>
<li><strong>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</strong>。</li>
</ol>
<h4 id="2-TreeSet"><a href="#2-TreeSet" class="headerlink" title="2. TreeSet"></a>2. TreeSet</h4><ol>
<li>底层采用二叉树得数据结构，对新add得对象按照指定得顺序排序，每增加一个对象都会进行排序，将对象插入到二叉树得指定位置</li>
<li>只有Integer类和String类型得对象才可以进行默认得TreeSet排序，而自定义类的对象是不可以的，自己定义得类必须实现Comparable接口，并覆写相应得compareto函数，才可以正常使用</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数</li>
</ol>
<h4 id="3-LinkHashSet"><a href="#3-LinkHashSet" class="headerlink" title="3. LinkHashSet"></a>3. LinkHashSet</h4><p>对于 LinkedHashSet 而言， 它继承与 HashSet 、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<h3 id="2-3-3-HashMap"><a href="#2-3-3-HashMap" class="headerlink" title="2.3.3 HashMap"></a>2.3.3 HashMap</h3><p>见<a target="_blank" rel="noopener" href="https://tonyxb.github.io/2020/07/12/HashMap/">HashMap详解</a></p>
<blockquote>
<p>HashMap源码分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认大小是16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16 </span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	  *默认加载因子是0.75</span></span><br><span class="line"><span class="comment">	  */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中不难看出HashMap是线程不安全的会出现多个线程同时读写，造成数据不一致得问题，因此可以通过以下方式解决</p>
<ol>
<li><p>HashTable ：Hashtable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下Hashtable的效率非常低下。因为当一个线程访问Hashtable的同步方法时，其他线程访问Hashtable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
</li>
<li><p>ConCurrentHashMap</p>
<ul>
<li>ConCurrentHashMap采用分段锁得机制解决线程不安全得问题。HashTable容器在竞争激烈得并发环境下表现效率低下的原因是因为所有访问HashTable的线程都必须竞争同一把锁，如果容器里有多把锁，每一把锁用于锁住容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争,从而可以有效地提高并发访问效率，这就是ConcurrentHashMap所采用的分段锁技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个数据段时，其他数据段也能被其他线程访问。</li>
<li>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁，在ConcurrentHashMap里扮演锁的角色，HashEntry用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表的结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构元素，每个Segment保护着一个HashEntry数组里的元素，如果想对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁</li>
<li>JDK8抛弃了分段锁机制，而是利用CAS+Sychronized来保证并发操作得安全性，数组结构采用：数组+链表+红黑树</li>
</ul>
<blockquote>
<p>ConcurrentHashMap构造函数源码分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)<span class="comment">//判断参数是否合法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :<span class="comment">//最大为2^30</span></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));<span class="comment">//根据参数调整table的大小</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;<span class="comment">//获取容量</span></span><br><span class="line">    <span class="comment">//ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调整table的大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;<span class="comment">//返回一个大于输入参数且最小的为2的n次幂的数。</span></span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>put操作源码分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//哈希算法</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<span class="comment">//无限循环，确保插入成功</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//表为空或表长度为0</span></span><br><span class="line">            tab = initTable();<span class="comment">//初始化表</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;<span class="comment">//i = (n - 1) &amp; hash为索引值，查找该元素，</span></span><br><span class="line">        <span class="comment">//如果为null,说明第一次插入</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//MOVED=-1;当前正在扩容，一起进行扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent &amp;&amp; fh == hash &amp;&amp;  <span class="comment">// check first node</span></span><br><span class="line">                 ((fk = f.key) == key || fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)) &amp;&amp;</span><br><span class="line">                 (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;<span class="comment">//其他情况加锁同步</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希算法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保证拿到最新的数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CAS操作插入节点，比较数组下标为i的节点是否为c，若是，用v交换，否则不操作。</span></span><br><span class="line"><span class="comment">//如果CAS成功，表示插入成功，结束循环进行addCount(1L, binCount)看是否需要扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>table 扩容操作源码分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    ... 省略部分代码</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;<span class="comment">// sc &lt; 0 表明此时有别的线程正在进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                <span class="comment">// 不满足前面5个条件时，尝试参与此次扩容，把正在执行transfer任务的线程数加1，+2代表有1个，+1代表有0个</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//试着让自己成为第一个执行transfer任务的线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);<span class="comment">// 去执行transfer任务</span></span><br><span class="line">            s = sumCount();<span class="comment">// 重新计数，判断是否需要开启下一轮扩容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>get操作源码分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断table是否为空，如果为空，直接返回null</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *2.计算key的Hash值，并获取指定table中指定位置的Node节点，通过遍历链表或者树结构找到响应的节点，返回value值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结:</p>
<p>Hashtable的任何操作都会把整个表锁住，是阻塞的。好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。<br> ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。<br> 应该根据具体的应用场景选择合适的HashMap。</p>
</li>
</ol>
<h2 id="2-4-深克隆与浅克隆"><a href="#2-4-深克隆与浅克隆" class="headerlink" title="2 .4 深克隆与浅克隆"></a>2 .4 深克隆与浅克隆</h2><ul>
<li>浅克隆: 只对克隆的实例进行复制，但对其中的引用对象，则不复制引用。还是公用一份内存地址中的值</li>
<li>深克隆: 会复制它内部对象的引用，里面所有的变量和子对象都是又额外拷贝了一份</li>
</ul>
<h2 id="2-5-Java序列化与反序列化"><a href="#2-5-Java序列化与反序列化" class="headerlink" title="2.5 Java序列化与反序列化"></a>2.5 Java序列化与反序列化</h2><ul>
<li>序列化: 将Java对象转化为字节序列</li>
<li>反序列化: 将字节序列反序列化为Java对象</li>
</ul>
<blockquote>
<p>作用与优点:</p>
</blockquote>
<ol>
<li>实现了数据的持久化，通过序列化可以将数据永久的保存在硬盘上</li>
<li>利用序列化实现远程网络通信，在网络上传送对象的二进制字节流</li>
</ol>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li>transinent修饰的变量在反序列化后对应的值就没了</li>
<li>序列化是不能序列化static变量的，static属于类，保存的是类的状态</li>
<li>要加上序列化ID</li>
</ul>
<h2 id="2-6-拆装箱"><a href="#2-6-拆装箱" class="headerlink" title="2.6 拆装箱"></a>2.6 拆装箱</h2><p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化，反之就是自动拆箱</p>
<ul>
<li>同类型的进行比较，如Integer 与int，Long与long进行==比较时，会自动拆箱；不同类型之间进行比较，如果有一方为非包装类，则会自动拆箱。如果两方不同类型且都为包装类，则不会拆箱，且不能比较，编译会报错</li>
<li>两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关</li>
<li>两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true</li>
<li>基本型封装类型调用equals(),但是后面参数是基本类型，则后面参数会先装箱</li>
</ul>
<h2 id="2-7-值传递与引用传递"><a href="#2-7-值传递与引用传递" class="headerlink" title="2.7 值传递与引用传递"></a>2.7 值传递与引用传递</h2><ul>
<li>值传递不能改改变原变量的内容与地址</li>
<li>引用传递不可以改变原变量的地址值，但可以改变地址中的内容</li>
<li>引用传递其实传递的是一个引用的副本</li>
</ul>
<h2 id="2-8-内部类"><a href="#2-8-内部类" class="headerlink" title="2.8 内部类"></a>2.8 内部类</h2><h3 id="2-8-1-内部类分类"><a href="#2-8-1-内部类分类" class="headerlink" title="2.8.1 内部类分类"></a>2.8.1 内部类分类</h3><ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态内部类</li>
</ul>
<h3 id="2-8-2-成员内部类"><a href="#2-8-2-成员内部类" class="headerlink" title="2.8.2 成员内部类"></a>2.8.2 成员内部类</h3><ul>
<li>成员内部类可以访问外部类所有的属性和方法，但是外部类访问内部类必须先创建内部类实例</li>
<li>成员内部类不能有static属性和方法</li>
<li>成员内部类可以用四种修饰符，private修饰的内部类以及内部类的方法和成员变量只能它所属的外部类访问。</li>
</ul>
<h3 id="2-8-3-局部内部类"><a href="#2-8-3-局部内部类" class="headerlink" title="2.8.3 局部内部类"></a>2.8.3 局部内部类</h3><p>定义在一个方法或者作用域内，访问仅限于该方法或作用域内</p>
<h3 id="2-8-3-匿名内部类"><a href="#2-8-3-匿名内部类" class="headerlink" title="2.8.3 匿名内部类"></a>2.8.3 匿名内部类</h3><p>使用一个匿名内部类我们必须继承一个父类或实现一个接口，它也没有class关键字<br>不能是抽象的，也不能被重复使用~<br>不能定义构造函数，不能存在静态成员变量和静态方法</p>
<h2 id="2-9-泛型"><a href="#2-9-泛型" class="headerlink" title="2.9 泛型"></a>2.9 泛型</h2><ul>
<li>编译时有效，运行时擦除</li>
</ul>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>通过变量类型限制，提高安全性</li>
<li>消除强制类型转换</li>
</ul>
<blockquote>
<p>通配符</p>
</blockquote>
<ul>
<li>无界通配符(&lt;?&gt;)</li>
<li>带有下边界的通配符(&lt;? super E&gt;)</li>
<li>带有上边界的通配符(&lt;? extends E&gt;)</li>
</ul>
<h2 id="3-0-初始化对象的方式"><a href="#3-0-初始化对象的方式" class="headerlink" title="3.0 初始化对象的方式"></a>3.0 初始化对象的方式</h2><ul>
<li>new语句(调用构造器)</li>
<li>反射机制(调用构造器)</li>
<li>Object.clone()方法</li>
<li>反序列化</li>
</ul>
<h2 id="3-1-反射机制"><a href="#3-1-反射机制" class="headerlink" title="3.1 反射机制"></a>3.1 反射机制</h2><p>在运行状态时，通过类的全限定类名就能将这个类的所有方法和变量信息(方法名，变量名，方法，修饰符，类型，方法参数等)找出来。如果明确知道这个类里的某个方法名+参数个数 类型，还能通过传递参数来运行那个类里的那个方法。</p>
<blockquote>
<p>获得类类型的三种方法</p>
</blockquote>
<ul>
<li>通过类名.class获得，执行静态代码块，不执行动态构造块，动态构造块在newInstance的时候执行</li>
<li>通过对象名.getClass()方法获得，实例化对象时，执行静态代码块与动态代码块</li>
<li>通过Class.forName(“类全名”)获得，执行静态块、不执行动态构造块，动态构造块在newInstance的时候执行</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">Java语言基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/16/Java%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java后端基础复习---Java虚拟机</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/07/JVM%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM阶段性总结</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Alan_</div><div class="author-info__description">Code Change The Word</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">94</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Alan-Joker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Alan-Joker" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tony_xb@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1623249948&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一. Java语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.面向对象的三大特征？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 八种基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 重载与重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 接口与抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Object%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 Object类的基本方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 静态变量，静态方法，静态代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 基本数据类型与引用数据类型区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-JVM-JRE-JDK-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">2.1 JVM JRE JDK 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Java%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.</span> <span class="toc-text">2.2 Java变量初始值问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Java%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.12.</span> <span class="toc-text">2.3 Java集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-List"><span class="toc-number">1.12.1.</span> <span class="toc-text">2.3.1 List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ArrayList"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">1. ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-LinkList"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">2. LinkList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Set"><span class="toc-number">1.12.2.</span> <span class="toc-text">2..3.2 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HashSet"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">1. HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TreeSet"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">2. TreeSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-LinkHashSet"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">3. LinkHashSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-HashMap"><span class="toc-number">1.12.3.</span> <span class="toc-text">2.3.3 HashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%B7%B1%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B5%85%E5%85%8B%E9%9A%86"><span class="toc-number">1.13.</span> <span class="toc-text">2 .4 深克隆与浅克隆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.14.</span> <span class="toc-text">2.5 Java序列化与反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">1.15.</span> <span class="toc-text">2.6 拆装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">1.16.</span> <span class="toc-text">2.7 值传递与引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.17.</span> <span class="toc-text">2.8 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%86%E7%B1%BB"><span class="toc-number">1.17.1.</span> <span class="toc-text">2.8.1 内部类分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-2-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.17.2.</span> <span class="toc-text">2.8.2 成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.17.3.</span> <span class="toc-text">2.8.3 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.17.4.</span> <span class="toc-text">2.8.3 匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.18.</span> <span class="toc-text">2.9 泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-0-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.19.</span> <span class="toc-text">3.0 初始化对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">1.20.</span> <span class="toc-text">3.1 反射机制</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/11/Lc670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/" title="Lc670-最大交换"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc670-最大交换"/></a><div class="content"><a class="title" href="/2021/11/11/Lc670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/" title="Lc670-最大交换">Lc670-最大交换</a><time datetime="2021-11-11T02:57:10.000Z" title="发表于 2021-11-11 10:57:10">2021-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/09/Lc662-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/" title="Lc662-二叉树的最大宽度"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc662-二叉树的最大宽度"/></a><div class="content"><a class="title" href="/2021/11/09/Lc662-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/" title="Lc662-二叉树的最大宽度">Lc662-二叉树的最大宽度</a><time datetime="2021-11-09T02:38:51.000Z" title="发表于 2021-11-09 10:38:51">2021-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/08/Lc124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" title="Lc124-二叉树中的最大路径和"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc124-二叉树中的最大路径和"/></a><div class="content"><a class="title" href="/2021/11/08/Lc124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" title="Lc124-二叉树中的最大路径和">Lc124-二叉树中的最大路径和</a><time datetime="2021-11-08T03:07:34.000Z" title="发表于 2021-11-08 11:07:34">2021-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/08/Lc128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" title="Lc128-最长连续序列"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc128-最长连续序列"/></a><div class="content"><a class="title" href="/2021/11/08/Lc128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" title="Lc128-最长连续序列">Lc128-最长连续序列</a><time datetime="2021-11-08T02:40:07.000Z" title="发表于 2021-11-08 10:40:07">2021-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/03/Lc958-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%A0%A1%E9%AA%8C/" title="Lc958-二叉树的完全校验"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc958-二叉树的完全校验"/></a><div class="content"><a class="title" href="/2021/11/03/Lc958-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%A0%A1%E9%AA%8C/" title="Lc958-二叉树的完全校验">Lc958-二叉树的完全校验</a><time datetime="2021-11-03T03:15:54.000Z" title="发表于 2021-11-03 11:15:54">2021-11-03</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Alan_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'h6wvO0pPfvBht9mEPGani2rG-MdYXbMMI',
      appKey: 'vj4PRecDeAq4WtHwIglfft5V',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script></div></body></html>