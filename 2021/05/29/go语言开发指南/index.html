<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>go语言开发指南 | Alan_</title><meta name="keywords" content="Go"><meta name="author" content="Alan_"><meta name="copyright" content="Alan_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="数据结构数组概述数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用 定义与初始化Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 [...]T 声明数组，Go 语言会在编译期间通过源代码推导数组的大小">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言开发指南">
<meta property="og:url" content="http://example.com/2021/05/29/go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="Alan_">
<meta property="og:description" content="数据结构数组概述数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用 定义与初始化Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 [...]T 声明数组，Go 语言会在编译期间通过源代码推导数组的大小">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/pic/silece.png">
<meta property="article:published_time" content="2021-05-29T06:12:07.000Z">
<meta property="article:modified_time" content="2021-05-30T09:36:12.000Z">
<meta property="article:author" content="Alan_">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/pic/silece.png"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="http://example.com/2021/05/29/go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-30 17:36:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Alan_" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/pic/silece.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Alan_</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">go语言开发指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-29T06:12:07.000Z" title="发表于 2021-05-29 14:12:07">2021-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-30T09:36:12.000Z" title="更新于 2021-05-30 17:36:12">2021-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数组是由<strong>相同类型</strong>元素的集合组成的数据结构，计算机会为数组分配一块<strong>连续的内存</strong>来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用</p>
<h3 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h3><p>Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码推导数组的大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导</p>
<h3 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h3><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <code>cmd/compile/internal/gc.anylit</code>函数中做两种不同的优化：</p>
<ol>
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	t := n.Type</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line">		<span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fixedlit(inInitFunction, initKindLocalCode, n, var_, init)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组的元素<strong>小于或者等于四个</strong>时，<code>cmd/compile/internal/gc.fixedlit</code>会负责在函数编译之前将 <code>[3]&#123;1, 2, 3&#125;</code> 转换成更加原始的语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedlit</span><span class="params">(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> splitnode <span class="function"><span class="keyword">func</span><span class="params">(*Node)</span> <span class="params">(a *Node, value *Node)</span></span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">		a, value := splitnode(r)</span><br><span class="line">		a = nod(OAS, a, value)</span><br><span class="line">		a = typecheck(a, ctxStmt)</span><br><span class="line">		<span class="keyword">switch</span> kind &#123;</span><br><span class="line">		<span class="keyword">case</span> initKindStatic:</span><br><span class="line">			genAsStatic(a)</span><br><span class="line">		<span class="keyword">case</span> initKindLocalCode:</span><br><span class="line">			a = orderStmtInPlace(a, <span class="keyword">map</span>[<span class="keyword">string</span>][]*Node&#123;&#125;)</span><br><span class="line">			a = walkstmt(a)</span><br><span class="line">			init.Append(a)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组中元素的个数小于或者等于四个并且 <code>cmd/compile/internal/gc.fixedlit</code>函数接收的 <code>kind</code> 是 <code>initKindLocalCode</code> 时，上述代码会将原有的初始化语句 <code>[3]int&#123;1, 2, 3&#125;</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>但是如果当前数组的元素大于四个，<code>cmd/compile/internal/gc.anylit</code>函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	t := n.Type</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line">		<span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">			vstat := staticname(t)</span><br><span class="line">			vstat.Name.SetReadonly(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">			fixedlit(inNonInitFunction, initKindStatic, n, vstat, init)</span><br><span class="line"></span><br><span class="line">			a := nod(OAS, var_, vstat)</span><br><span class="line">			a = typecheck(a, ctxStmt)</span><br><span class="line">			a = walkexpr(a, init)</span><br><span class="line">			init.Append(a)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结起来，在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入<code>中间代码生成</code>和<code>机器码生成</code>两个阶段，最后生成可以执行的二进制文件。</p>
<h3 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h3><p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据</p>
<p>数组访问越界是非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界，<code>cmd/compile/internal/gc.typecheck1</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OINDEX:</span><br><span class="line">		ok |= ctxExpr</span><br><span class="line">		l := n.Left  <span class="comment">// array</span></span><br><span class="line">		r := n.Right <span class="comment">// index</span></span><br><span class="line">		<span class="keyword">switch</span> n.Left.Type.Etype &#123;</span><br><span class="line">		<span class="keyword">case</span> TSTRING, TARRAY, TSLICE:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> n.Right.Type != <span class="literal">nil</span> &amp;&amp; !n.Right.Type.IsInteger() &#123;</span><br><span class="line">				yyerror(<span class="string">&quot;non-integer array index %v&quot;</span>, n.Right)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">				x := n.Right.Int64()</span><br><span class="line">				<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">					yyerror(<span class="string">&quot;invalid array index %v (index must be non-negative)&quot;</span>, n.Right)</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.Left.Type.IsArray() &amp;&amp; x &gt;= n.Left.Type.NumElem() &#123;</span><br><span class="line">					yyerror(<span class="string">&quot;invalid array index %v (out of bounds for %d-element array)&quot;</span>, n.Right, n.Left.Type.NumElem())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>访问数组的索引是非整数时，报错 “non-integer array index %v”；</li>
<li>访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)”；</li>
<li>访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)”；</li>
</ol>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组；但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言运行时阻止不合法的访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">4</span>]: invalid array index <span class="number">4</span> (out of bounds <span class="keyword">for</span> <span class="number">3</span>-element array)</span><br><span class="line">arr[i]: <span class="built_in">panic</span>: runtime error: index out of <span class="keyword">range</span> [<span class="number">4</span>] with length <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <code>runtime.panicIndex</code> 触发程序的运行时错误并导致崩溃退出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·panicIndex(SB),NOSPLIT,$<span class="number">0</span><span class="number">-8</span></span><br><span class="line">	MOVL	AX, x+<span class="number">0</span>(FP)</span><br><span class="line">	MOVL	CX, y+<span class="number">4</span>(FP)</span><br><span class="line">	JMP	runtime·goPanicIndex(SB)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goPanicIndex</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	panicCheck1(getcallerpc(), <span class="string">&quot;index out of range&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(boundsError&#123;x: <span class="keyword">int64</span>(x), signed: <span class="literal">true</span>, y: y, code: boundsIndex&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组的访问操作 <code>OINDEX</code> 成功通过编译器的检查后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 ssa.html 文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> check</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outOfRange</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	i := <span class="number">4</span></span><br><span class="line">	elem := arr[i]</span><br><span class="line">	<span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOSSAFUNC=outOfRange <span class="keyword">go</span> build array.<span class="keyword">go</span></span><br><span class="line">dumped SSA to ./ssa.html</span><br></pre></td></tr></table></figure>

<p><code>start</code> 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分是 <code>elem := arr[i]</code> 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 <code>IsInBounds</code> 以及当条件不满足时触发程序崩溃的 <code>PanicBounds</code> 指令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v22 (<span class="number">6</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v20</span><br><span class="line">    v23 (<span class="number">6</span>) = IsInBounds &lt;<span class="keyword">bool</span>&gt; v21 v11</span><br><span class="line">If v23 → b2 b3 (likely) (<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">b2: ← b1-</span><br><span class="line">    v26 (<span class="number">6</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v22 v21</span><br><span class="line">    v27 (<span class="number">6</span>) = Copy &lt;mem&gt; v20</span><br><span class="line">    v28 (<span class="number">6</span>) = Load &lt;<span class="keyword">int</span>&gt; v26 v27 (elem[<span class="keyword">int</span>])</span><br><span class="line">    ...</span><br><span class="line">Ret v30 (+<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">b3: ← b1-</span><br><span class="line">    v24 (<span class="number">6</span>) = Copy &lt;mem&gt; v20</span><br><span class="line">    v25 (<span class="number">6</span>) = PanicBounds &lt;mem&gt; [<span class="number">0</span>] v21 v11 v24</span><br><span class="line">Exit v25 (<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>编译器会将 <code>PanicBounds</code> 指令转换成上面提到的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.panicIndex"><code>runtime.panicIndex</code></a> 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标、利用 <code>PtrIndex</code> 计算出目标元素的地址，最后使用 <code>Load</code> 操作将指针中的元素加载到内存中。</p>
<p>当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 <code>PanicBounds</code> 指令交给运行时进行判断，在使用字面量整数访问数组下标时会生成非常简单的中间代码，当我们将上述代码中的 <code>arr[i]</code> 改成 <code>arr[2]</code> 时，就会得到如下所示的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v21 (<span class="number">5</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v20</span><br><span class="line">    v22 (<span class="number">5</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v21 v14</span><br><span class="line">    v23 (<span class="number">5</span>) = Load &lt;<span class="keyword">int</span>&gt; v22 v20 (elem[<span class="keyword">int</span>])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>数组在 Go 语言中没那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。</p>
<p>在 Go 语言中，切片类型的声明方式与数组有一些相似，不过由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>从切片的定义我们能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即 <code>int</code> 或者 <code>interface&#123;&#125;</code> 等。<code>cmd/compile/internal/types.NewSlice</code>就是编译期间用于创建切片类型的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">(elem *Type)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t := elem.Cache.slice; t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.Elem() != elem &#123;</span><br><span class="line">			Fatalf(<span class="string">&quot;elem mismatch&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := New(TSLICE)</span><br><span class="line">	t.Extra = Slice&#123;Elem: elem&#125;</span><br><span class="line">	elem.Cache.slice = t</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法返回结构体中的 <code>Extra</code> 字段是一个只包含切片内元素类型的结构，也就是说切片内元素的类型都是在编译期间确定的，编译器确定了类型之后，会将类型存储在 <code>Extra</code> 字段中帮助程序在运行时动态获取。</p>
<p>编译期间的切片是 <code>cmd/compile/internal/types.Slice</code>类型的，但是在运行时切片可以由如下的 <code>reflect.SliceHeader</code></p>
<ul>
<li><code>Data</code> 是指向数组的指针;</li>
<li><code>Len</code> 是当前切片的长度；</li>
<li><code>Cap</code> 是当前切片的容量，即 <code>Data</code> 数组的大小：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Data</code> 是一片连续的内存空间，这片内存空间可以用于存储切片中的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<p><img src="/pic/silece.png"></p>
<p>从上图中，我们会发现切片与数组的关系非常密切，切片引入了一个抽象层，提供了对数组中部分连续片段的引用，而作为数组的引用，我们可以在运行区间可以修改它的长度和范围。当切片底层的数组长度不足时就会触发扩容，切片指向的数组可能会发生变化，不过在上层看来切片是没有变化的，上层只需要与切片打交道不需要关心数组的变化。</p>
<h3 id="定义与初始化-1"><a href="#定义与初始化-1" class="headerlink" title="定义与初始化"></a>定义与初始化</h3><p>Go 语言中包含三种初始化切片的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字 <code>make</code> 创建切片：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>:<span class="number">3</span>] or slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3></blockquote>
<p>使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，编译器会将 <code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 等语句转换成 <code>OpSliceMake</code> 操作，我们可以通过下面的代码来验证一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> opslicemake</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSlice</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	slice := arr[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>GOSSAFUNC</code> 变量编译上述代码可以得到一系列 SSA 中间代码，其中 <code>slice := arr[0:1]</code> 语句在 “decompose builtin” 阶段对应的代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v27 (+<span class="number">5</span>) = SliceMake &lt;[]<span class="keyword">int</span>&gt; v11 v14 v17</span><br><span class="line"></span><br><span class="line">name &amp;arr[*[<span class="number">3</span>]<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.ptr[*<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.<span class="built_in">len</span>[<span class="keyword">int</span>]: v14</span><br><span class="line">name slice.<span class="built_in">cap</span>[<span class="keyword">int</span>]: v17</span><br></pre></td></tr></table></figure>

<p><code>SliceMake</code> 操作会接受四个参数创建新的切片，元素类型、数组指针、切片大小和容量，<strong>需要注意的是使用下标初始化切片不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。</strong></p>
<blockquote>
<p>字面量</p>
</blockquote>
<p>当我们使用字面量 <code>[]int&#123;1, 2, 3&#125;</code> 创建新的切片时，<code>cmd/compile/internal/gc.slicelit</code>函数会在编译期间将它展开成如下所示的代码片段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">3</span>]<span class="keyword">int</span> = <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">*vauto = vstat</span><br><span class="line">slice := vauto[:]</span><br></pre></td></tr></table></figure>

<ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点我们也能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<blockquote>
<p>关键字</p>
</blockquote>
<p>如果使用字面量的方式创建切片，大部分的工作都会在编译期间完成。但是当我们使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须向 <code>make</code> 函数传入切片的大小以及可选的容量，类型检查期间的 <code>cmd/compile/internal/gc.typecheck1</code></p>
<p>上述函数不仅会检查 <code>len</code> 是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>。除了校验参数之外，当前函数会将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，中间代码生成的 <code>cmd/compile/internal/gc.walkexpr</code>函数会依据下面两个条件转换 <code>OMAKESLICE</code> 类型的节点：</p>
<ol>
<li>切片的大小和容量是否足够小；</li>
<li>切片是否发生了逃逸，最终在堆上初始化</li>
</ol>
<p>当切片发生逃逸或者非常大时，运行时需要 <code>runtime.makeslice</code>在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<p>当切片发生逃逸或者非常大时，运行时需要 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.makeslice"><code>runtime.makeslice</code></a> 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>上述代码会初始化数组并通过下标 <code>[:3]</code> 得到数组对应的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组并将 <code>[:3]</code> 转换成 <code>OpSliceMake</code> 操作。</p>
<p>于创建切片的运行时函数 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.makeslice"><code>runtime.makeslice</code></a>，这个函数的实现很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">		<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()</span><br><span class="line">		&#125;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go</p>
<p>上述函数的主要工作是计算切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：</p>
<p>内存空间=切片中元素大小×切片容量内存空间=切片中元素大小×切片容量</p>
<p>虽然编译期间可以检查出很多错误，但是在创建切片的过程中如果发生了以下错误会直接触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量；</li>
</ol>
<p><code>runtime.makeslice</code>函数的实现还是比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的对象会在堆上初始化</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OLEN, OCAP:</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">			op := ssa.OpSliceLen</span><br><span class="line">			<span class="keyword">if</span> n.Op == OCAP &#123;</span><br><span class="line">				op = ssa.OpSliceCap</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> s.newValue1(op, types.Types[TINT], s.expr(n.Left))</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问切片中的字段可能会触发 “decompose builtin” 阶段的优化，<code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会直接替换成切片的长度或者容量，不需要在运行时获取：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(SlicePtr (SliceMake ptr _ _ )) -&gt; ptr</span><br><span class="line">(SliceLen (SliceMake _ <span class="built_in">len</span> _)) -&gt; <span class="built_in">len</span></span><br><span class="line">(SliceCap (SliceMake _ _ <span class="built_in">cap</span>)) -&gt; <span class="built_in">cap</span></span><br></pre></td></tr></table></figure>

<p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OINDEX:</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">			p := s.addr(n, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> s.load(n.Left.Type.Elem(), p)</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含 <code>range</code> 关键字的遍历转换成形式更简单的循环，我们会在后面的章节中介绍使用 <code>range</code> 遍历切片的过程。</p>
<h3 id="追加与扩容"><a href="#追加与扩容" class="headerlink" title="追加与扩容"></a>追加与扩容</h3><p>使用 <code>append</code> 关键字向切片中追加元素也是常见的切片操作，中间代码生成阶段的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.append"><code>cmd/compile/internal/gc.state.append</code></a> 方法会根据返回值是否会覆盖原变量，选择进入两种流程，如果 <code>append</code> 返回的新切片不需要赋值回原有的变量，就会进入如下的处理流程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// append(slice, 1, 2, 3)</span></span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> newlen &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> = growslice(slice, newlen)</span><br><span class="line">    newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line"><span class="keyword">return</span> makeslice(ptr, newlen, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<p>我们会先解构切片结构体获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <code>runtime.growslice</code>对切片进行扩容并将新的元素依次加入切片。</p>
<p>如果使用 <code>slice = append(slice, 1, 2, 3)</code> 语句，那么 <code>append</code> 后的切片会覆盖原切片，这时 <code>cmd/compile/internal/gc.state.append</code> 方法会使用另一种方式展开关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice = append(slice, 1, 2, 3)</span></span><br><span class="line">a := &amp;slice</span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint</span>(newlen) &gt; <span class="keyword">uint</span>(<span class="built_in">cap</span>) &#123;</span><br><span class="line">   newptr, <span class="built_in">len</span>, newcap = growslice(slice, newlen)</span><br><span class="line">   vardef(a)</span><br><span class="line">   *a.<span class="built_in">cap</span> = newcap</span><br><span class="line">   *a.ptr = newptr</span><br><span class="line">&#125;</span><br><span class="line">newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">*a.<span class="built_in">len</span> = newlen</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>是否覆盖原变量的逻辑其实差不多，最大的区别在于得到的新切片是否会赋值回原变量。如果我们选择覆盖原有的变量，就不需要担心切片发生拷贝影响性能，因为 Go 语言编译器已经对这种常见的情况做出了优化。</p>
<p>当切片的容量不足时，我们会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 函数为切片扩容，扩容是为切片分配新的内存空间并拷贝原切片中元素的过程，我们先来看新切片的容量是如何确定的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p>上述代码片段仅会确定切片的大致容量，下面还需要根据切片中的元素大小对齐内存，当数组中元素所占的字节大小为 1、8 或者 2 的倍数时，运行时会使用如下所示的代码对齐内存：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">	lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">	newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">	capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">	overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">	newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">	lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">	newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">	capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">	overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">	newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，我们会将目标容量和元素大小相乘得到占用的内存。如果计算新容量时发生了内存溢出或者请求内存超过上限，就会直接崩溃退出程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem, _ = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		capmem = roundupsize(capmem)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(p), <span class="keyword">uintptr</span>(old.array), lenmem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memmove(p, old.array, lenmem)</span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果切片中元素不是指针类型，那么会调用 <code>runtime.memclrNoHeapPointers</code> 将原数组内存中的内容拷贝到新申请的内存中。</p>
<p><code>runtime.growslice</code>，其中包含了新的数组指针、大小和容量，这个返回的三元组最终会覆盖原切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr []<span class="keyword">int64</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>简单总结一下扩容的过程，当我们执行上述代码时，会触发 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a>期望分配的内存大小为 40 字节；不过因为切片中的元素大小等于 <code>sys.PtrSize</code>，所以运行时会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.roundupsize"><code>runtime.roundupsize</code></a> 8 = 6。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中 <code>runtime.hmap</code>是最核心的结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="keyword">int</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段，它的大小是当前 <code>buckets</code> 的一半；</li>
</ol>
<p><img src="/pic/hmap.png"></p>
<p>如上图所示哈希表 <code>runtime.hmap</code> 的桶是 <code>runtime.bmap</code>都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶已经装满时就会使用 <code>extra.nextOverflow</code> 中桶存储溢出的数据。</p>
<p>上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 <code>runtime.bmap</code>就是正常桶，绿色的 <code>runtime.bmap</code>使用 C 语言实现时使用的设计<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:3">3</a>，由于它能够减少扩容的频率所以一直使用至今。</p>
<p>桶的结构体 <code>runtime.bmap</code>在 Go 语言源代码中的定义只包含一个简单的 <code>tophash</code> 字段，<code>tophash</code> 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行期间，<code>runtime.bmap</code>段，因为哈希表中可能存储不同类型的键值对，而且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导。<code>runtime.bmap</code>就不包含这些字段，不过我们能根据编译期间的 <code>cmd/compile/internal/gc.bmap</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p>
<p>从 Go 语言哈希的定义中可以发现，改进元素比数组和切片复杂得多，它的结构体中不仅包含大量字段，还使用复杂的嵌套结构</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Go 语言初始化哈希的两种方法 — 通过字面量和运行时</p>
<blockquote>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3></blockquote>
<p>目前的现代编程语言基本都支持使用字面量的方式初始化哈希，一般都会使用 <code>key: value</code> 的语法来表示键值对，Go 语言中也不例外：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;3&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">&quot;5&quot;</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在初始化哈希时声明键值对的类型，这种使用字面量初始化的方式最终都会通过<code>cmd/compile/internal/gc.maplit</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *Node, m *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	a := nod(OMAKE, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	a.Esc = n.Esc</span><br><span class="line">	a.List.Set2(typenod(n.Type), nodintconst(<span class="keyword">int64</span>(n.List.Len())))</span><br><span class="line">	litas(m, a, init)</span><br><span class="line"></span><br><span class="line">	entries := n.List.Slice()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build list of var[c] = expr.</span></span><br><span class="line">	<span class="comment">// Use temporaries so that mapassign1 can have addressable key, elem.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当哈希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>这种初始化的方式与的<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/">数组</a>和<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">切片</a>几乎完全相同，由此看来集合类型的初始化在 Go 语言中有着相同的处理逻辑。</p>
<p>一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, ... ， <span class="string">&quot;26&quot;</span>&#125;</span><br><span class="line">vstatv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里展开的两个切片 <code>vstatk</code> 和 <code>vstatv</code> 还会被编辑器继续展开，具体的展开方式可以阅读上一节了解，不过无论使用哪种方法，使用字面量初始化的过程都会使用 Go 语言中的关键字 <code>make</code> 来创建新的哈希并通过最原始的 <code>[]</code> 语法向哈希追加元素。</p>
<blockquote>
<h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3></blockquote>
<p>当创建的哈希被分配到栈上并且其容量小于 <code>BUCKETSIZE = 8</code> 时，Go 语言在编译阶段会使用如下方式快速初始化哈希，这也是编译器对小容量的哈希做的优化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h *hmap</span><br><span class="line"><span class="keyword">var</span> hv hmap</span><br><span class="line"><span class="keyword">var</span> bv bmap</span><br><span class="line">h := &amp;hv</span><br><span class="line">b := &amp;bv</span><br><span class="line">h.buckets = b</span><br><span class="line">h.hash0 = fashtrand0()</span><br></pre></td></tr></table></figure>

<p>除了上述特定的优化之外，无论 <code>make</code> 是从哪里来的，只要我们使用 <code>make</code> 创建哈希，Go 语言编译器都会在类型检查期间将它们转换成 <code>runtime.makemap</code>最后调用的都是 <code>runtime.makemap</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="keyword">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会按照下面的步骤执行：</p>
<ol>
<li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li>
<li>调用<code>runtime.fastrand</code>]获取一个随机的哈希种子；</li>
<li>根据传入的 <code>hint</code> 计算出需要的最小需要的桶的数量；</li>
<li>使用 <code>runtime.makeBucketArray</code> 创建用于保存桶的数组；</li>
</ol>
<p><code>runtime.makeBucketArray</code>会根据传入的 <code>B</code> 计算出的需要创建的桶数量并在内存中分配一片连续的空间用于存储数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="keyword">uint8</span>, dirtyalloc unsafe.Pointer)</span> <span class="params">(buckets unsafe.Pointer, nextOverflow *bmap)</span></span> &#123;</span><br><span class="line">	base := bucketShift(b)</span><br><span class="line">	nbuckets := base</span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets</span><br><span class="line">		up := roundupsize(sz)</span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buckets = newarray(t.bucket, <span class="keyword">int</span>(nbuckets))</span><br><span class="line">	<span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">		nextOverflow = (*bmap)(add(buckets, base*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当桶的数量小于 2424 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li>
<li>当桶的数量多于 2424 时，会额外创建 2B−42B−4 个溢出桶；</li>
</ul>
<p>根据上述代码，我们能确定在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，只是被<code>runtime.hmap</code> 中的不同字段引用，当溢出桶数量较多时会通过 <code>runtime.newobject</code></p>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><p>哈希表的访问一般都是通过下标或者遍历进行的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = hash[key]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">    <span class="comment">// k, v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式虽然都能读取哈希表的数据，但是使用的函数和底层原理完全不同。前者需要知道哈希的键并且一次只能获取单个键对应的值，而后者可以遍历哈希中的全部键值对，访问数据时也不需要预先知道哈希的键。</p>
<p>数据结构的写一般指的都是增加、删除和修改，增加和修改字段都使用索引和赋值语句，而删除字典中的数据需要使用关键字 <code>delete</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash[key] = value</span><br><span class="line">hash[key] = newValue</span><br><span class="line"><span class="built_in">delete</span>(hash, key)</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapassign</p>
<p>函数会在以下两种情况发生时触发哈希的扩容：</p>
<ol>
<li>装载因子已经超过 6.5；</li>
<li>哈希使用了太多溢出桶；</li>
</ol>
<p>不过因为 Go 语言哈希的扩容不是一个原子的过程，所以 <code>runtime.mapassign</code>]还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱。</p>
<p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 <code>sameSizeGrow</code>，<code>sameSizeGrow</code> 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏runtime: limit the number of map overflow buckets引入了 <code>sameSizeGrow</code> 通过复用已有的哈希扩容机制解决该问题，一旦哈希中出现了过多的溢出桶，它会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">	oldbuckets := h.buckets</span><br><span class="line">	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	h.B += bigger</span><br><span class="line">	h.flags = flags</span><br><span class="line">	h.oldbuckets = oldbuckets</span><br><span class="line">	h.buckets = newbuckets</span><br><span class="line">	h.nevacuate = <span class="number">0</span></span><br><span class="line">	h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">	h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	h.extra.nextOverflow = nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希在扩容的过程中会通过 <code>runtime.makeBucketArray</code>了相同的逻辑更新，下图展示了触发扩容后的哈希： </p>
<p>我们在 <code>runtime.hashGrow</code> 中还看不出来等量扩容和翻倍扩容的太多区别，等量扩容创建的新桶数量只是和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转移。哈希表的数据迁移的过程在是 <code>runtime.evacuate</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	newbit := h.noldbuckets()</span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">		<span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">		x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">		x.v = add(x.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">		y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">		y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">		y.v = add(y.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br></pre></td></tr></table></figure>



<p><code>runtime.evacuate</code>]会将一个旧桶中的数据分流到两个新桶，所以它会创建两个用于保存分配上下文的 <code>runtime.evacDst</code></p>
<p><img src="/pic/htable" alt="image-20210530140631149"></p>
<h3 id="哈希表扩容目的"><a href="#哈希表扩容目的" class="headerlink" title="哈希表扩容目的"></a><strong>哈希表扩容目的</strong></h3><p>如果这是等量扩容，那么旧桶与新桶之间是一对一的关系，所以两个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.evacDst"><code>runtime.evacDst</code></a> 只会初始化一个。而当哈希表的容量翻倍时，每个旧桶的元素会都分流到新创建的两个桶中，这里仔细分析一下分流元素的逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">			v := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(v, <span class="keyword">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line">				top := b.tophash[i]</span><br><span class="line">				k2 := k</span><br><span class="line">				<span class="keyword">var</span> useY <span class="keyword">uint8</span></span><br><span class="line">				hash := t.key.alg.hash(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">				<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">					useY = <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">				b.tophash[i] = evacuatedX + useY</span><br><span class="line">				dst := &amp;xy[useY]</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">					dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">					dst.i = <span class="number">0</span></span><br><span class="line">					dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">					dst.v = add(dst.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				&#125;</span><br><span class="line">				dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top</span><br><span class="line">				typedmemmove(t.key, dst.k, k)</span><br><span class="line">				typedmemmove(t.elem, dst.v, v)</span><br><span class="line">				dst.i++</span><br><span class="line">				dst.k = add(dst.k, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				dst.v = add(dst.v, <span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只使用哈希函数是不能定位到具体某一个桶的，哈希函数只会返回很长的哈希，例如：<code>b72bfae3f3285244c4732ce457cca823bc189e0b</code>，我们还需一些方法将哈希映射到具体的桶上。我们一般都会使用取模或者位操作来获取桶的编号，假如当前哈希中包含 4 个桶，那么它的桶掩码就是 0b11(3)，使用位操作就会得到 3， 我们就会在 3 号桶中存储该数据：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">0xb72bfae3f3285244c4732ce457cca823bc189e0b</span> &amp; <span class="number">0b11</span> <span class="comment">#=&gt; 0</span></span><br></pre></td></tr></table></figure>

<p>如果新的哈希表有 8 个桶，在大多数情况下，原来经过桶掩码 <code>0b11</code> 结果为 3 的数据会因为桶掩码增加了一位变成 <code>0b111</code> 而分流到新的 3 号和 7 号桶，所有数据也都会被 runtime.typedmemmove拷贝到目标桶中</p>
<h3 id="哈希表桶数据的分流"><a href="#哈希表桶数据的分流" class="headerlink" title="哈希表桶数据的分流"></a><strong>哈希表桶数据的分流</strong></h3><p><code>runtime.evacuate</code>增加哈希的 <code>nevacuate</code> 计数器并在所有的旧桶都被分流后清空哈希的 <code>oldbuckets</code> 和 <code>oldoverflow</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	h.nevacuate++</span><br><span class="line">	stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">	<span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">		stop = newbit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">		h.nevacuate++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.nevacuate == newbit &#123; <span class="comment">// newbit == # of oldbuckets</span></span><br><span class="line">		h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.flags &amp;^= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go</p>
<p>之前在分析哈希表访问函数 <code>runtime.mapaccess1</code>时其实省略了扩容期间获取键值对的逻辑，当哈希表的 <code>oldbuckets</code> 存在时，会先定位到旧桶并在该桶没有被分流时从中获取键值对。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">bucketloop:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为旧桶中的元素还没有被 <code>runtime.evacuate</code>函数分流，其中还保存着我们需要使用的数据，所以旧桶会替代新创建的空桶提供数据。</p>
<p>我们在 <code>runtime.mapassign</code>函数中也省略了一段逻辑，当哈希表正在处于扩容状态时，每次向哈希表写入值时都会触发<code>runtime.growWork</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">again:</span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了写入操作之外，删除操作也会在哈希表扩容期间触发 <code>runtime.growWork</code></p>
<p>哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，扩容过程不是原子的，而是通过<code>runtime.growWork</code>希表写入数据时会触发旧桶元素的分流。除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 <code>sameSizeGrow</code> 这一机制，在出现较多溢出桶时会整理哈希的内存减少空间的占用。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="/pic/silece.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/21/Alan-%E5%BE%97%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Alan_得算法模板</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/09/%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/"><img class="next-cover" src="/pic/%E8%AF%BB%E5%86%99%E6%8C%87%E9%92%88.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一条更新语句的执行</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Alan_</div><div class="author-info__description">Code Change The Word</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Alan-Joker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Alan-Joker" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tony_xb@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1623249948&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">定义与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.3.</span> <span class="toc-text">语句转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.4.</span> <span class="toc-text">访问和赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">1.2.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">定义与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87"><span class="toc-number">1.2.3.</span> <span class="toc-text">使用下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.4.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="toc-number">1.2.5.</span> <span class="toc-text">追加与扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">运行时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.5.</span> <span class="toc-text">读写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">1.3.6.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%AE%B9%E7%9B%AE%E7%9A%84"><span class="toc-number">1.3.7.</span> <span class="toc-text">哈希表扩容目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%A1%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E6%B5%81"><span class="toc-number">1.3.8.</span> <span class="toc-text">哈希表桶数据的分流</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/12/Lc763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/" title="Lc763-划分字母区间"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc763-划分字母区间"/></a><div class="content"><a class="title" href="/2021/11/12/Lc763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/" title="Lc763-划分字母区间">Lc763-划分字母区间</a><time datetime="2021-11-12T01:41:35.000Z" title="发表于 2021-11-12 09:41:35">2021-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/11/Lc670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/" title="Lc670-最大交换"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc670-最大交换"/></a><div class="content"><a class="title" href="/2021/11/11/Lc670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/" title="Lc670-最大交换">Lc670-最大交换</a><time datetime="2021-11-11T02:57:10.000Z" title="发表于 2021-11-11 10:57:10">2021-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/09/Lc662-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/" title="Lc662-二叉树的最大宽度"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc662-二叉树的最大宽度"/></a><div class="content"><a class="title" href="/2021/11/09/Lc662-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/" title="Lc662-二叉树的最大宽度">Lc662-二叉树的最大宽度</a><time datetime="2021-11-09T02:38:51.000Z" title="发表于 2021-11-09 10:38:51">2021-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/08/Lc124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" title="Lc124-二叉树中的最大路径和"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc124-二叉树中的最大路径和"/></a><div class="content"><a class="title" href="/2021/11/08/Lc124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" title="Lc124-二叉树中的最大路径和">Lc124-二叉树中的最大路径和</a><time datetime="2021-11-08T03:07:34.000Z" title="发表于 2021-11-08 11:07:34">2021-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/08/Lc128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" title="Lc128-最长连续序列"><img src="/pic/head.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lc128-最长连续序列"/></a><div class="content"><a class="title" href="/2021/11/08/Lc128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" title="Lc128-最长连续序列">Lc128-最长连续序列</a><time datetime="2021-11-08T02:40:07.000Z" title="发表于 2021-11-08 10:40:07">2021-11-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Alan_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'h6wvO0pPfvBht9mEPGani2rG-MdYXbMMI',
      appKey: 'vj4PRecDeAq4WtHwIglfft5V',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script></div></body></html>